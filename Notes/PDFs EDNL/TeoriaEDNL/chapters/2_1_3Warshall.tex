El \textit{algoritmo de Warshall} determina \textbf{si hay un camino entre cada par de vértices} del grafo \textbf{no ponderado} \(G\).

\begin{minted}[breaklines]{C++}
matriz<bool> Warshall(const Grafo& G)
\end{minted}
Como salida tenemos:
\begin{itemize}
  \item Una \textbf{matriz booleana} cuadrada de tamaño \texttt{G.numVert()}, donde la posición \texttt{[i][j]} es \texttt{true} si existe al menos un camino entre los vértice \(i\) y \(j\), y es \texttt{false} si no existe un camino entre ese par de vértices.
\end{itemize}

\subsection{Código del algoritmo de Warshall}
\subsubsection{Algoritmo de Warshall}
\begin{minted}[breaklines]{C++}
matriz<bool> Warshall(const Grafo& G){
  typedef Grafo::vertice vertice;
  const size_t n = G.numVert();
  matriz<bool>A(n); //creamos la matriz de booleanos.
//Inicializamos A con la matriz de adyacencia.
  for(vertice i = 0; i<=n-1; i++){
    A[i] = G[i];
    A[i][i] = true;
  }
// Comprobar camino entre cada par de vértices i, j
// a través de cada vértice k.
  for(vertice k = 0; k <= n-1; k++)
    for(vertice i = 0; i <= n-1; i++)
      for(vertice j = 0; j <= n-1; j++){
        if(!A[i][j]){
          A[i][j] = A[i][k] && A[k][j];
        }
      }
  return A;
}
\end{minted}

Cosas a tener en cuenta del código:
\begin{itemize}
  \item Con \texttt{A[i][i] = true} \(\rightarrow\) indicamos que hay camino, es decir, siempre hay camino entre un vétice cualquiera y sí mismo.
  \item Con \texttt{!A[i][j]} \(\rightarrow\) comprobamos si hay o no camino entre dicho par de vértice (si es \texttt{true} o \texttt{false}).
  \item \texttt{A[i][j] = A[i][k] \&\& A[k][j]} \(\rightarrow\) se ejecuta en el caso de que lo anterior fuera \texttt{false} (no hay camino), donde comprobamos si hay camino entre \(i, j\), pero pasando por otro vértice cualquiera \(k\).
\end{itemize}
