Anteriormente, tanto en los árboles binarios como generales trabajábamos con nodos. Ahora en los árboles binarios de búsqueda vamos a trabajar con subárboles dependiendo de un valor `e'.

\subsection*{Constructor del árbol binario de búsqueda}
\underbar{\textit{Postcondición:}} Crea y devuelve un ABB vacío.\\
\verb|  Abb();|
\subsection*{Inserción de elementos en el ABB}
\underbar{\textit{Postcondición:}} Si `e' no pertence al árbol, lo inserta, en caso contrario el árbol no se modifica.\\
\verb|  void insertar(const T& e);| 
\subsection*{Eliminación de elementos del ABB}
\underbar{\textit{Postcondición:}} Si `e' se encuentra en el árbol, lo elimina, en caso contrario, el árbol no se modifica.\\
\verb|  void eliminar(const T& e);|
\subsection*{Métodos observadores de un ABB}
\begin{itemize}
  \item \underbar{\large\textbf{Obtener el subárbol}}:\\
  \underbar{\textit{Postcondición:}} Si `e' pertence al árbol devuelve el subárbol (cuya raíz es `e'), si no, devuelve un subárbol vacío.\\
  \verb|  const Abb& buscar(const T& e)const;|
  \item \underbar{\large\textbf{Estado vacío}}:\\ 
  \underbar{\textit{Postcondición:}} Devuelve \texttt{True} si el árbol está vacío, si no, \texttt{False}.\\
  \verb|  bool vacio()const;|
  \item \underbar{\large\textbf{Obtener subárbol izquierdo}}:\\
  \underbar{\textit{Precondición:}} Árbol no vacío.\\
  \underbar{\textit{Postcondición:}} Devuelve el subárbol izquierdo.\\
  \verb|  const Abb& izqdo()const;|
  \item \underbar{\large\textbf{Obtener subárbol derecho}}:\\
  \underbar{\textit{Precondición:}} Árbol no vacío.\\
  \underbar{\textit{Postcondición:}} Devuelve el subárbol derecho.\\
  \verb|  const Abb& drcho()const;|
\end{itemize}