\subsection{Implementación vectorial del TAD árbol binario}
A diferencia de la implementación mediante celdas enlazadas aquí si conocemos el número máximo de nodos del árbol, además haremos uso de un vector (como bien dice su nombre) de celdas que también almacenará el elemento y los nodos padre, hijo izquierdo y derecho. Véase \textit{Figura 2.1: Representación de la implementación vectorial.}

\begin{figure}[h]
  \begin{center}
    \includegraphics*[width=\textwidth]{assets/IVEC1.png}
  \end{center}
  \caption{Representación de la implementación vectorial.}
\end{figure}

Ahora en la parte privada del TAD encontramos dos variables \texttt{numNodos}(número actual de nodos del árbol) y \texttt{maxNodos}(tamaño del árbol), ahora tenemos que tener en cuenta al primero para poder insertar y eliminar en coste unitario (\(O(1)\)), el segundo nos hará falta para poder crear el árbol ya que en este caso el constructor recibe por parámetro el numero máximo de nodos, es decir, \texttt{maxNodos} → \verb|Abin(size_t maxNodos);|

Para que la eliminación de nodos sea de coste unitario debemos de mover el último nodo insertado a la última posición del vector.

\subsubsection*{Implementación de Inserción y Eliminación de los nodos}
\begin{itemize}
  \item \underbar{\large\textbf{Inserción}}: En la inserción de un nodo tenemos que tener en cuenta el número actual de nodos que hay en el árbol ya que este tiene que ser menor a \texttt{maxNodos}, esto nos ayudará a que la inserción sea de coste unitario, ya que accedemos a la última posición del vector (sin tener que recorrer todo el árbol):
  \begin{verbatim}
template <typename T>
inline void Abin<T>::insertarHijoIzqdo(nodo n, const T& e){
  //Precondiciones
  assert(n>=0 && n <numNodos); //nodo valido
  assert(n->hizq == NODO_NULO); //n no tiene hijo izquierdo previo
  assert(numNodos < maxNodos); //árbol no lleno
  //Inserción del nodo
  nodos[numNodos].hizq = numNodos; //el nuevo nodo se inserta al final
  nodos[numNodos].elto = e; //almacenamos el elemento
  nodo[numNodos].hizq = NODO_NULO; //no tiene hijo izquierdo
  nodo[numNodos].hder= NODO_NULO; //no tiene hijo derecho
  numNodos ++; //incrementamos el número de nodos actuales en el vector.
}
  \end{verbatim}
  \item \underbar{\large\textbf{Eliminación}}: La eliminación de un nodo siempre va a ser de coste unitario, debido a que se elimina el hijo de un nodo n `padre' (el cual tenemos acceso directo).
  \begin{verbatim}
template <typename T> inline void Abin<T>::eliminarHijoIzqdo(nodo n){
  nodo hizqdo; //creamos un nodo auxiliar
  //Precondiciones
  assert(n>=0 && n < numNodos);
  hizqdo = nodos[n].hizq; //guardamos el hijo izquierdo del nodo n
  assert(hizqdo != NODO_NULO); //existe hijo izquierdo de n
  assert(nodos[hizqdo].hizq == NODO_NULO &&
    nodos[hizqdo].hder == NODO_NULO); // es Hoja
  
  //Comprobamos si el hijo izquierdo de n no es el último nodo insertado.
  if(hizqdo != numNodos - 1){
    //Movemos el último nodo a la posición del hijo izqdo
    nodos[hizqdo] = nodos[numNodos-1];
    //Actualizamos la posición del hijo en la padre del nodo movido(hizqdo)
    if(nodos[nodos[hizqdo].padre].hizq == numNodos - 1){
      nodos[nodo[hizqdo].padre].hizq = hizqdo;
    }
    else{
      nodos[nodos[hizqdo].padre].hder = hizqdo;
    }
    //Si el movido tiene hijos, solamente cambiamos el padre
    if(nodos[hizqdo].hizq!=NODO_NULO) //Si tiene hijo izquierdo
      nodos[nodo[hizqdo].hizq].padre = hizqdo;
    if(nodos[hizqdo].hder != NODO_ NULO)
      nodos[nodos[hizqdo].hder].padre = hizqdo;
  }
  nodos[n].hizq = NODO_NULO;
  --numNodos;
}
  \end{verbatim}
\end{itemize}
Es decir, movemos el último nodo insertado a la posición del nodo que vamos a eliminar para que podamos insertar siempre por el final (última posición del vector) haciendo que sea de coste unitario.\\
\textit{NOTA}: Análogamente para el hijo derecho.
