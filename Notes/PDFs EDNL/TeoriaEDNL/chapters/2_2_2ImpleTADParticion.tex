El TAD partición podemos implementarlo de diversas maneras (vector, listas, árboles,..), por tanto, vamos a ver como se implementan los algoritmos anteriores.

\textbf{Implementación mediante vector de pertenencia}

En cada posición del vector vamos a encontrar el representante de cada subconjunto.
\begin{figure}[h]
  \begin{center}
    \includegraphics[width=\textwidth]{assets/impPAR1.png}
  \end{center}
  \caption{Ejemplo implementación vector de pertenencia}
\end{figure}

Vemos que en el subconjunto \(\{0,4\}\), en la posición `\textbf{0}' del vector, econtramos el representante `\textbf{4}', es decir, cada elemento en negrita es el representante del subconjunto.

Si queremos unir dos subconjuntos, primero llamaremos al método \texttt{encontrar()} y luego al método \texttt{unir()}.

El coste de las operaciones son:
\begin{itemize}
  \item \texttt{encontrar()} \(\in O(1)\), porque accedemos a la posición directamente.
  \item \texttt{unir()} \(\in O(n)\), porque recorremos todo el vector.
  \item \texttt{Partición()} \(\in O(n)\).
\end{itemize}
\newpage
Vamos a ver un ejemplo, uniendo los subconjunto de los elemento 4 y 1:
\begin{figure}[h]
  \begin{center}
    \includegraphics[width=\textwidth]{assets/impPAR2.png}
  \end{center}
  \caption{Resultado implementación vector de pertenencia}
\end{figure}

Vemos que todos los `1' del vector han pasado a ser `4', es decir, todos los elementos que estaban en el subconjunto donde el representante era el valor `1' se han incluido en el subconjunto cuyo representante es el valor `4'.

\textbf{Implementación mediante lista de elementos}

Es una implementación cuya eficiencia espacial es menor (se gasta más espacio).

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=\textwidth]{assets/impPAR3.png}
  \end{center}
  \caption{Ejemplo implementación lista de elementos}
\end{figure}

Ahora almacenamos tanto el `vector de pertenencia' (\(P\)) que contiene el representante de cada subconjunto y un campo que indica que elemento le precede, en el caso del elemento `0' el valor es -1, es decir, no hay más valores en el subconjunto, pero si nos vamos al elemento `8' vemos que su valor es 9, es decir que el elemento `8' precede al elemento `9'.

Queremos realizar la operación \texttt{unir(4,1)}, como vemos en la \textit{Figura 10.4}, tanto el elemento `4' como el `1' son representantes de sus subconjuntos, por tanto si realizamos la unión los valores que suceden a los elementos va a cambiar, quedando:
\begin{figure}[h]
  \begin{center}
    \includegraphics[width=\textwidth]{assets/impPAR4.png}
  \end{center}
  \caption{Resultado implementación lista de elementos}
\end{figure}

Es decir, si nos fijamos en el valor que tenía anteriormente el elemento `4' que era 0, ahora vemos que ese valor es 1 (ahora del elemento 4 vamos al elemento 1), además podemos ver que el representante de los elementos `1', `6', `8' y `9' ahora es `4', el representante del nuevo subconjunto.

El coste de las operaciones son:
\begin{itemize}
  \item \texttt{encontrar()} \(\in O(1)\), porque accedemos a la posición directamente.
  \item \texttt{unir()} \(\in O(n)\), pero el tiempo de ejecución es menor.
\end{itemize}
\newpage
\textbf{Implementación mediante lista de elementos con longitud}

Esta implementación es muy parecida a la anteror, pero contiene un campo más para poder evitar el peor caso.

En este nuevo campo almacenamos la longitud para así evitar unir una lista larga con una corta, haciendo que siempre se una una corta a una larga.

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=\textwidth]{assets/impPAR5.png}
  \end{center}
  \caption{Ejemplo implementación lista de elementos con longitud}
\end{figure}

Si nos fijamos en la \textit{Figura 10.6} veremos que el elemento `0' su representante es el elemento `4', además es el último elemento del subconjunto, ya que tiene el valor -1 y al ser el último elemento su longitud es `nada' (el cuadro negro), a diferencia del elemento `7' cuyo representante es el elemento `7', su sucesor es el elemento `2' y la longitud es 3 (porque es el número de elementos del subconjunto), solamente los representantes tienen este valor asignado.

Vamos a realizar la operación \texttt{unir(4,1)}:

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=\textwidth]{assets/impPAR6.png}
  \end{center}
  \caption{Resultado implementación lista de elementos con longitud}
\end{figure}

Como vemos, se realizan los mismos cambios que en el ejemplo anterior (\textit{Figura 10.5: Resultado implementación lista de elementos}), pero con el extra de que tenemos que cambiar la longitudes de los representantes.
Al unir los subconjuntos de los elementos `4' y `1' y al ser el nuevo representante del nuevo subconjunto el elemento `1' este cambiará su longitud de 4 a 6.

Porqué es el elemento `1' el nuevo representante y no `4', esto se debe a que ahora unimos el \textbf{subconjunto corto} al \textbf{subconjunto largo}, como el subconjunto cuyo representante era `4' era el corto en comparación al subconjunto con representante `1' obtenemos el resultado del la \textit{Figura 10.7}.

Ahora el coste de las operaciones son:
\begin{itemize}
  \item \texttt{encontrar()} \(\in O(1)\), porque accedemos a la posición directamente.
  \item \texttt{unir()} \(\in O(n)\), pero el tiempo de ejecución se reduce a la mitad.
\end{itemize}
\newpage
\textbf{Implementación mediante bosque de árboles}

Ahora cada subconjunto pasan a ser árboles (lo más ancho posible). En cada posición del vector vamos a encontrar el \textbf{padre} de dicho elemento en el árbol, donde el \textbf{representante} del subconjunto será el nodo \textbf{raíz} de dicho árbol.

Al igual que en los ejemplos anteriores el valor -1 indicará la ausencia de elemento en dicho árbol, en este caso, indicará que ese nodo no tendrá padre y por ende será el representante (nodo ráiz).

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=\textwidth]{assets/impPAR7.png}
  \end{center}
  \caption{Ejempo implementación bosque de árboles}
\end{figure}

Ahora si queremos unir los subconjuntos cuyos representantes son 4,1, es decir realizar la operación \texttt{unir(4,1)}, tendríamos que unir el árbol con representante `1' en el árbol con representante `4' o viceversa:
\begin{figure}[h]
  \begin{center}
    \includegraphics[width=\textwidth]{assets/impPAR9.png}
  \end{center}
  \caption{Resultado implementación bosque de árboles}
\end{figure}

En este caso, hemos unido el árbol del subconjunto con representante `1' al del representante `4' (\textit{Figura 10.9}), es decir el segundo se une al primero.

En este caso el coste de las operaciones son:
\begin{itemize}
  \item \texttt{encontrar()} \(\in O(n)\).
  \item \texttt{unir()} \(\in O(1)\).
\end{itemize}
\newpage
\textbf{Implementación mediante bosque de árboles con control de altura}

Sin embargo, si tenemos árboles (subconjuntos) muy grandes y muy pequeños puede ser muy ineficiente la operación \texttt{unir()}, para poder subsanar este problema encontramos la implementación mediante \textit{bosque de árboles con control de altura}, donde el unimos el árbol más bajo al más alto, ya que la altura no sube (cota).

Una altura inferior \(\rightarrow\) mayor equilibrio del árbol.

Si los árboles tiene la misma altura, da igual quien se una a quien.

Vamos a diferenciar dos tipos de uniónes:
\begin{itemize}
  \item \underbar{\textbf{Unión por tamaño:}}
  El árbol con menos nodos se convierte en el subárbol del que tiene mayor número de nodos.

  Es una alternativa a hacerlo por azar.

  En este caso, lo relevante no es la altura, si no el tamaño de árbol (como su nombre dice), además un error muy común es pensar que mayor tamaño \(\implies\) mayor altura, esto no es así debido a que un árbol general puede tener muchos nodos hermanos y su altura puede seguir siendo 1.

  \item \underbar{\textbf{Unión por altura:}}
  El árbol menos alto se convierte en subárbol del otro.

  Esta implementación es la más acertada, debido a que vamos a unir el árbol `más pequeño' al más `grande', haciendo que el árbol resultante crezca en anchura.
  \begin{figure}[h]
    \begin{center}
      \includegraphics[width=\textwidth]{assets/impPAR11.png}
    \end{center}
    \caption{Ejemplo bosque de árboles control de altura (unión por altura)}
  \end{figure}

Ahora en el vector de pertenencia \(P\), si el nodo padre, encontramos que el valor indica la altura del árbol - 1 (en negativo), es decir, se pone \(-(altura\_arbol-1)\). Cuando la altura es 0 ponemos el valor -1, debido a que encontramos una ambigüedad en el caso de -0.

Ahora al unir dos árboles, la operación \texttt{encontrar()} pasa a ser de coste \(O(log\ n)\), ya que vamos descartando las ramas donde no se encuentra dicho valor.

Vamos a realizar la operación \texttt{unir(4,1)}:

Como vemos en la \textit{Figura 10.10} el árbol con representante (raíz)`4' es mucho más pequeño que el árbol con raíz `1', por tanto, el primero se convertirá en subárbol del árbol con raíz `1', haciendo que el árbol gane anchura y la altura no se vea incrementada (\textit{Figura 10.11}).

Finalmente, vemos que en el vector el contenido del elemento `4' pasa a ser -2(altura del árbol anterior) a 1 (su nodo padre).
\begin{figure}[h]
  \begin{center}
    \includegraphics[width=\textwidth]{assets/impPAR12.png}
  \end{center}
  \caption{Resultado bosque de árboles control de altura (unión por altura)}
\end{figure}
Si ambos árboles tienen la misma altura, da igual en el orden que insertemos los subárboles.

\item \underbar{\textbf{Compresión de caminos:}} Optimiza la altura de los árboles.

Ahora con la primera pasada sabemos el representante del nodo `x' a encontrar, en la segunda pasada ya sabemos todos los nodos que pertenecen a dicho representante.

Queremos realizar la operación \texttt{encontrar(20)}:

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=.9\textwidth]{assets/impPAR13.png}
  \end{center}
  \caption{Ejemplo bosque de árboles control de altura (compresión de caminos)}
\end{figure}

En la primera pasada encontramos que el representante del subconjunto de 20, es el elemento `10', en la segunda pasada colocamos el elemento `20' como hijo izquierdo del representante (elemento `10') y así sucesivamente con todos los elementos del subconjunto.

Si nos fijamos en el vector de pertenencia \(P\), el elemento `18' tiene como representante al elemento `10', pero esto no se corresponde con el árbol visto en la \textit{Figura 10.12}, por tanto, vamos a optimizar su altura, haciendo que el nodo con valor `18' sea ahora un hijo del nodo con valor `10', lo mismo con el elemento `14'.

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=.9\textwidth]{assets/impPAR14.png}
  \end{center}
  \caption{Resultado bosque de árboles control de altura (compresión de caminos)}
\end{figure}

Vemos que los nodos 20,14 y 18 (señalados en rojo) han cambiado de posición en el árbol, disminuyendo la altura e incrementando la anchura del mismo, además si nos fijamos en le vector de pertenencia los valores de elementos 20(14) ,14(18) y 18(25) han cambiado a 10.

Si hiceramos la operación \texttt{encontrar(16)}, tanto el nodo 16, como 9 cambiarían de posición siendo hijos de nodo 10 (su representante).
\end{itemize}

Gracias a esto el coste de las operaciones son:
\begin{itemize}
  \item \texttt{encontrar()} \(O(log\ n)\).
  \item \texttt{unir()} \(\in O(1)\).
\end{itemize}

\textbf{Código de la implementación mediante bosque de árboles control de altura}

\begin{minted}[breaklines]{C++}
class Particion{
  public:
    Particion(int n): padre(n-1){}
    void unir(int a, int b);
    int encontrar(int x)const;
  private:
    mutable std::vector<int>padre;
};

void Particion::unir(int a, int b){
  if(padre[b] < padre[a]){
    padre[a] = b;
  }
  else if(padre[a] == padre[b]){//como aumenta la altura, le restamos 1
    padre[a]--; //árbol resultante tiene un nivel más
    padre[b] = a;
  }
}
int Particion::encontrar(int x)const{
  int y,raiz = x;
  while(padre[raiz] > -1){ //tiene padre y no es representante
    raiz = padre[raiz];
//Compresión del camino: lo nodos del camino se hacen hijos de la raiz.
    while(padre[x]> -1){
      y = padre[x];
      padre[x] =raiz;
      x = y;
    }
  }
  return raiz;
}
\end{minted}


