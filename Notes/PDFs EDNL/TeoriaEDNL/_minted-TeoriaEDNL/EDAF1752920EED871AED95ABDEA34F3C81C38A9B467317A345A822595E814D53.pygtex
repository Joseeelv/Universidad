\begin{Verbatim}[commandchars=\\\{\}]
\PYG{x}{template \PYGZlt{}typename tCoste\PYGZgt{} vector\PYGZlt{}tCoste\PYGZgt{} Dijkstra (const GrafoP\PYGZlt{}tCoste\PYGZgt{}\PYGZam{} G,typename GrafoP\PYGZlt{}tCoste\PYGZgt{}::vertice origen, vector\PYGZlt{}typename GrafoP\PYGZlt{}tCoste\PYGZgt{}::vertice\PYGZgt{}\PYGZam{} vertice)\PYGZob{}}
\PYG{x}{  typedef typename GrafoP\PYGZlt{}tCoste\PYGZgt{}::vertice vertice;}
\PYG{x}{  vertice v,w;}
\PYG{x}{  const size\PYGZus{}t n = G.numVert(); //guardamos el numero de vertices}
\PYG{x}{  vector\PYGZlt{}bool\PYGZgt{} S(n,false); //vector de booleanos inicializado a falso}
\PYG{x}{  vector\PYGZlt{}tCoste\PYGZgt{} D; //Costes minimos}
\PYG{x}{  //Inicializamos D y P con los caminos directos desde el origen}
\PYG{x}{  D = G[origen];}
\PYG{x}{  D[origen] = 0;}
\PYG{x}{  P = vector\PYGZlt{}vertice\PYGZgt{}(n,origen);}
\PYG{x}{  S[origen] = true;}
\PYG{x}{  // Localizar vértice w no incluido en S con menor coste desde origen.}
\PYG{x}{  for(size\PYGZus{}t i = 1; i\PYGZlt{}=n\PYGZhy{}2; i++)\PYGZob{}}
\PYG{x}{    tCoste costeMinimo = GrafoP\PYGZlt{}tCoste\PYGZgt{}::INFINITO;}
\PYG{x}{    for(v=0;v\PYGZlt{}= n\PYGZhy{}1; v++)\PYGZob{}}
\PYG{x}{      if(!S[v] \PYGZam{}\PYGZam{} D[V] \PYGZlt{}=costeMinimo)\PYGZob{}}
\PYG{x}{        costeMinimo = D[v];}
\PYG{x}{        w = v;}
\PYG{x}{      \PYGZcb{}}
\PYG{x}{    S[w] = true;}
\PYG{x}{  //Recalcular coste hasta cada v no incluido en S, a través de w.}
\PYG{x}{  //Aqui optimizamos de verdad, donde se recálcala los valores del vector.}
\PYG{x}{  for(v=0; v\PYGZlt{}=n\PYGZhy{}1; v++)}
\PYG{x}{    if(!S[v])\PYGZob{}}
\PYG{x}{      tCoste Owv = suma(D[w], G[w][v]);}
\PYG{x}{      if(Owv \PYGZlt{} D[v])}
\PYG{x}{    \PYGZcb{}}
\PYG{x}{  \PYGZcb{}}
\PYG{x}{\PYGZcb{}}
\end{Verbatim}
