\begin{Verbatim}[commandchars=\\\{\}]
\PYG{x}{template \PYGZlt{}typename tCoste\PYGZgt{} vector\PYGZlt{}tCoste\PYGZgt{} Dijkstra (const GrafoP\PYGZlt{}tCoste\PYGZgt{}\PYGZam{} G,typename GrafoP\PYGZlt{}tCoste\PYGZgt{}::vertice origen, vector\PYGZlt{}typename GrafoP\PYGZlt{}tCoste\PYGZgt{}::vertice\PYGZgt{}\PYGZam{} vertice)\PYGZob{}}
\PYG{x}{  typedef typename GrafoP\PYGZlt{}tCoste\PYGZgt{}::vertice vertice;}
\PYG{x}{  vertice v,w;}
\PYG{x}{  const size\PYGZus{}t n = G.numVert(); //guardamos el numero de vertices}
\PYG{x}{  vector\PYGZlt{}bool\PYGZgt{} S(n,false); //vector de booleanos inicializado a falso}
\PYG{x}{  vector\PYGZlt{}tCoste\PYGZgt{} D; //Costes minimos}
\PYG{x}{  //Inicializamos D y P con los caminos directos desde el origen}
\PYG{x}{  D = G[origen];}
\PYG{x}{  D[origen] = 0;}
\PYG{x}{  P = vector\PYGZlt{}vertice\PYGZgt{}(n,origen);}
\PYG{x}{  S[origen] = true;}
\PYG{x}{  // Localizar v√©rtice w no incluido en S con menor coste desde origen.}
\PYG{x}{  for(size\PYGZus{}t i = 1; i\PYGZlt{}=n\PYGZhy{}2; i++)\PYGZob{}}
\PYG{x}{    tCoste costeMinimo = GrafoP\PYGZlt{}tCoste\PYGZgt{}::INFINITO;}
\PYG{x}{    for(v=0;v\PYGZlt{})}
\PYG{x}{  \PYGZcb{}}
\PYG{x}{\PYGZcb{}}
\end{Verbatim}
