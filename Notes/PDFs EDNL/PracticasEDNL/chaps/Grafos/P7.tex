Esta práctica es una continuación de la anterior.

\textbf{\large\underbar{Ejercicio 1:}}\textit{ Tu agencia de viajes “OTRAVEZUNGRAFO S.A.” se enfrenta a un curioso cliente. Es un personaje sorprendente, no le importa el dinero y quiere hacer el viaje más caro posible entre las ciudades que ofertas. Su objetivo es gastarse la mayor cantidad de dinero posible (ojalá todos los clientes fueran así), no le importa el origen ni el destino del viaje.}

\textit{Sabiendo que es imposible pasar dos veces por la misma ciudad, ya que casualmente el grafo de tu agencia de viajes resultó ser acíclico, devolver el coste, origen y destino de tan curioso viaje. Se parte de la matriz de costes directos entre las ciudades del grafo.}

Partimos de que tenemos un grafo acíclico, la matriz de costes directos entre los vértices del mismo y queremos obtener los caminos con mayor coste entre las diferentes ciudades (vértices) del mismo, además no nos importa ni el origen ni destino del viaje, por lo que ya sabemos que algoritmo vamos a usar, en efecto Floyd.

Pero no vamos a hacer uso de un Floyd normal y corriente, debido a que este nos devuelve la matriz con los costes mínimos de todos los caminos posibles del grafo, ahora tenemos que devolver los caminos con mayor coste, por tanto, vamos a realizar una implementación de Floyd máximo para poder obtener el resultado esperado.

\begin{minted}[breaklines]{C++}
template <typename tCoste> tCoste MaxInteligente(tCoste a, tCoste b){
  if(a == GrafoP<tCoste>::INFINITO){
    return b;
  }
  if(b == GrafoP<tCoste>::INFINITO){
    return a;
  }
  return std::max(a,b);
}
template <typename tCoste> matriz<tCoste> Floyd_max(const GrafoP<tCoste> &G, matriz<typename GrafoP<tCoste>::vertice> &P){
  //Calculamos los caminos de coste máximo entre cada par de vértices del grafo G.
  typename GrafoP<tCoste>::vertice vertice;
  typename GrafoP<tCoste>::INFINITO INFINITO;
  const size_t n = G.numVert();
  matriz<vertice> A(n); //creamos la matriz con los costes máximos.
  //Inicializamos P y A.
  P = matriz<vertice>(n);
  for(size_t i = 0; i < n; i++){
    A[i] = G[i]; //Copiamos el coste del grafo
    A[i][i] = 0; //Diagonal principal a 0
    P[i] = vector<vertice>(n,i); //camino directos
  }
  //Calculamos los costes máximos y los caminos correspondientes
  for(vertice k = 0; k < n; k++)
    for(vertice i = 0; i < n, i++)
      for(vertice j = 0; j < n; j++){
        tCoste ikj = MaxInteligente(A[i][k],A[k][j]); //el coste de ir de i a j pasando por k.
        if(ikj > A[i][j] && ikj != INFINITO){
          A[i][j] = ikj;
          P[i][j] = k;
        }
      }
  return A; //devolvemos la matriz de costes máximos.
}

//Ya tenemos hecho el algoritmo Floyd_max, ahora vamos a calcular lo que nos pide el enunciado:
//Como tenemos que devolver el coste del camino entre ese origen-destino y ambas ciudades.
template <typename tCoste> tCoste viaje(const GrafoP<tCoste> &G, typename GrafoP<tCoste>::vertice &O, typename GrafoP<tCoste>::vertice &D){
  //Nos creamos la matriz para almacenar los costes máximos
  typename GrafoP<tCoste>::vertice vertice;
  matriz<vertice>P;
  matriz<tCoste>CosteMax;
  CosteMax = Floyd_max(G,P);
  typename GrafoP<tCoste>::INFINITO INFINITO;

  //nos creamos una variable que almacenará el coste del viaje del origen a destino
  tCoste viaje_max = std::numeric_limits<tCoste>::min();
  for(vertice i = 0; i < G.numVert(); i++)
    for(vertice j = 0; j <G.numVert(); j++){
      if(viaje_max < G[i][j] && G[i][j] != INFINITO){
        viaje_max = G[i][j]; //almacenamos el coste del viaje más costoso
        O = i; //almacenamos la ciudad origen del viaje
        D = j; //almacenamos la ciudad destino del viaje
      }
    }
  return viaje_max;
}
\end{minted}

\textbf{\large\underbar{Ejercicio 2:}}\textit{ Se dispone de un laberinto de NxN casillas del que se conocen las casillas de entrada y salida del mismo. Si te encuentras en una casilla sólo puedes moverte en las siguientes cuatro direcciones (arriba, abajo, derecha, izquierda). Por otra parte, entre algunas de las casillas hay una pared que impide moverse entre las dos casillas que separa dicha pared (en caso contrario no sería un verdadero laberinto).}

\textit{Implementa un subprograma que dados:
\begin{itemize}
  \item N (dimensión del laberinto),
  \item la lista de paredes del laberinto,
  \item la casilla de entrada, y
  \item la casilla de salida,
\end{itemize}
calcule el camino más corto para ir de la entrada a la salida y su longitud.}

Contamos con un laberinto de dos dimensiones \(N x N\), donde conocemos la casilla de entrada y la de salida. Ahora vemos que no tenemos un grafo de inicio, por tanto, a la función no podemos pasarle el grafo, si no que le pasamos la dimensión del laberinto y la casillas de salida y entrada.

Ahora encontramos un problema y es que nos piden que devolvamos el camino más corto de ir desde un origen a un destino, esto lo haremos mediante el uso de Dijkstra pero este algoritmo trabaja con grafos no con laberintos, por tanto, lo que vamos a hacer es convertir ese laberinto en un grafo, haciendo que esas casillas pasen a ser vértices del grafo, pero tenemos que buscar una función que eso se cumpla.

Como tenemos un laberinto de dimensión \(N x N\), vamos a tener un grafo de \(N^2\) nodos y una matriz de coste de \(N^2 x N^2\) posiciones.

Vamos a declarar los tipos de datos con los que vamos a trabajar:

Las casillas pues será una coordenada dentro del laberinto, es decir un par de dos enteros (por ejemplo) \(\rightarrow\) \texttt{typedef std::pair<int,int> Casilla;} ó una estructura \texttt{struct Casilla\{int fila\_; int columna\_;\};}

Un laberinto tiene paredes, por lo que al tener casillas, una pared será un par de dos casillas \(\rightarrow\) \texttt{std::pair<Casilla,Casilla> Pared;}, estas paredes estarán en aquellas casillas que sean adyacentes, por lo que necesitamos un método que dadas dos casillas
nos indique si son o no adyacentes.

A la hora de trabjar con el grafo para poder calcular el camino más corto entre la salida y la entrada, tenemos que convertir esas casillas a vértices del mismo, por tanto haremos uso de una función auxiliar llamada \texttt{casillaAvertice();}.


\begin{minted}[breaklines]{C++}
//Declaramos los tipos específicos del laberinto:
typedef std::pair<int,int> Casilla;
typedef std::pair<Casilla,Casilla> Pared;
typedef std::vector<Pared> paredes;
typedef GrafoP<size_t>::vertice vertice;

//Método que convierte un vértice en una casilla
Casilla verticeAcasilla(vertice v, int N){
  Casilla C;
  C.first = v/N;
  C.second = v%N;
  return C;
}

//Método que comprueba la adyacencia de casillas
bool adyacentes(Casilla a, Casilla b){
  return (std::abs(a.first - b.first) + std::abs(a.second - b.second()) ==1);
}

void rellena_adyacentes(GrafoP<size_t> &G, int N){
  for(vertice v = 0; v < G.numVert() ; v++)
    for(vertice w = 0; w < G.numVert(); w++){
      if(v == w)
        G[v][w] = 0;
      else if(adyacentes(verticeAcasilla(v,N)), verticeAcasilla(w,N))
         G[v][w] = 1;
    }
}

//Método que nos convierte de una casilla a un vértice
vertice casillaAvertice(Casilla C, size_t N){
  return C.first*N + C.second;
}

//Método que construye las paredes
void construye_paredes(GrafoP<size_t> &L, const paredes &p, int N){
  for(auto &pared : p){
    vertice v = casillaAvertice(p.first,N);
    vertice w = casillaAvertice(p.second,N);
    L[v][w] = L [w][v] = GrafoP<size_t>::INFINITO;
  }
}

//Método que nos calcula el camino más corto del Laberinto junto con su costes
std::pair<vector<vertice>,size_t> laberinto(int N, const paredes &p, Casilla inicio, Casilla fin){
  //Creamos el grafo con dimensión NxN
  size_t D = N*N:
  GrafoP<size_t> Laberinto(D);
  //convertimos las casillas de inico y fin a vértices del grafo
  vertice ini_ = casillaAvertice(inicio,N),
          fin_ = casillaAvertice(fin,N);

  //Rellenamos el grafo con los vértices adyacentes
  rellena_adyacentes(Laberinto,D);
  //Construimos paredes
  construye_paredes(Laberinto,p,dimension);

  //Creamos el vector de vértice y de coste mínimo para calcular el camino mínimo entre la casilla de inicio y fin del Laberinto
  vector<vertice>P;
  vector<size_t>costemin = Dijkstra(Laberinto,ini_,P);
  return std::make_pair(P,costemin[fin_]);
}
\end{minted}

\textbf{\large\underbar{Ejercicio 3:}}\textit{ Eres el orgulloso dueño de una empresa de distribución. Tu misión radica en distribuir todo tu stock entre las diferentes ciudades en las que tu empresa dispone de almacén.}

\textit{Tienes un grafo representado mediante la matriz de costes, en el que aparece el coste (por unidad de producto) de transportar los productos entre las diferentes ciudades del grafo.}

\textit{Pero además resulta que los Ayuntamientos de las diferentes ciudades en las que tienes almacén están muy interesados en que almacenes tus productos en ellas, por lo que están dispuestos a subvencionarte con un porcentaje de los gastos mínimos de transporte hasta la ciudad. Para facilitar el problema, consideraremos despreciables los costes de volver el camión a su base (centro de producción).}

\textit{He aquí tu problema. Dispones de
\begin{itemize}
  \item el centro de producción, nodo origen en el que tienes tu producto (no tiene almacén),
  \item una cantidad de unidades de producto (cantidad),
  \item la matriz de costes del grafo de distribución con N ciudades,
  \item la capacidad de almacenamiento de cada una de ellas,
  \item el porcentaje de subvención (sobre los gastos mínimos) que te ofrece cada Ayuntamiento.
\end{itemize}}
\textit{Las diferentes ciudades (almacenes) pueden tener distinta capacidad, y además la
capacidad total puede ser superior a la cantidad disponible de producto, por lo que debes decidir cuántas unidades de producto almacenas en cada una de las ciudades.
Debes tener en cuenta además las subvenciones que recibirás de los diferentes Ayuntamientos, las cuales pueden ser distintas en cada uno y estarán entre el 0\% y el 100\% de los costes mínimos.\\
La solución del problema debe incluir las cantidades a almacenar en cada ciudad bajo estas condiciones y el coste mínimo total de la operación de distribución para tu empresa.}

Partimos de que tenemos un grafo (matriz de costes), tenemos una ciudad origen (centro de producción), la cantidad de producto y el porcentaje de subvneción que ofrece cada ayuntamiento.

Como tenemos un origen (indicado explícitamente) haremos uso de Dijkstra, no hacemos DijkstraInv ya que nos dice que el coste de volver es despreciable por tanto, asumimos que es 0.
Luego de hacer Dijkstra (coste mínimo bruto), aplicaremos el porcentaje de subvención.
Finalmente, cogemos el que menor coste tenga y rellenamos la matriz de costes de más barato a más caro.
No buscamos el más barato directamente, ni el que mayor subvención recibe, si no el que más barato le salga al camón después de realizar el cálculo de los costes mínimos ya aplicada la subvención (coste mínimo neto).

\begin{minted}[breaklines]{C++}
% //Definimos los tipos
% typedef GrafoP<size_t>::vertice vertice;
% typedef std::vector<size_t> cantidades;
% typedef std::vector<size_t> porcentajes;

% //Nos creamos un método el cual nos servirá para aplicar las subvenciones
% void subvencion(cantidades &v, porcentajes &subvencion){
%   for(size_t i = 0; i < v.size(); i++){
%     v[i] -= v[i] * (subvenciones[i]/100);

%   }
% }

\end{minted}

\textbf{\large\underbar{Ejercicio 4:}}\textit{ Eres el orgulloso dueño de la empresa “Cementos de Zuelandia S.A”. Empresa dedicada a la fabricación y distribución de cemento, sita en la capital de Zuelandia. Para la distribución del cemento entre tus diferentes clientes (ciudades de Zuelandia) dispones de una flota de camiones y de una plantilla de conductores zuelandeses.}

\textit{El problema a resolver tiene que ver con el carácter del zuelandés. El zuelandés es una persona que se toma demasiadas “libertades” en su trabajo, de hecho, tienes fundadas sospechas de que tus conductores utilizan los camiones de la empresa para usos particulares (es decir indebidos, y a tu costa) por lo que quieres controlar los kilómetros que recorren tus camiones.}

\textit{Todos los días se genera el parte de trabajo, en el que se incluyen el número de cargas de cemento (1 carga = 1 camión lleno de cemento) que debes enviar a cada cliente (cliente = ciudad de Zuelandia). Es innecesario indicar que no todos los días hay que enviar cargas a todos los clientes, y además, puedes suponer razonablemente que tu flota de camiones es capaz de hacer el trabajo diario.}

\textit{Para la resolución del problema quizá sea interesante recordar que Zuelandia es un país cuya especial orografía sólo permite que las carreteras tengan un sentido de circulación.}

\textit{Implementa una función que dado el grafo con las distancias directas entre las diferentes ciudades zuelandesas, el parte de trabajo diario, y la capital de Zuelandia, devuelva la distancia total en kilómetros que deben recorrer tus camiones en el día, para que puedas descubrir si es cierto o no que usan tus camiones en actividades ajenas a la empresa.}

Partimos de que tenemos un grafo con los costes directos, la cantidad de cemento que se reparte a cada ciudad, una ciudad origen (que es la capital) y nos piden devolver la distancia en kilómetros que deben de recorrer los camiones, es decir, el coste mínimo de un dia de trabajo.

Para ello vamos a hacer uso de Dijkstra para la ida de los camiones y DijkstraInv para la vuelta de los mismos, la suma de ambos costes serán los kilómetros que hace cada camión.

\begin{minted}[breaklines]{C++}
//Definimos los tipos que vamos a usar
typedef double km;
typedef GrafoP<km>::vertice vertice; //cada vertice = ciudad
typedef size_t carga;
typedef std::vector<cargar> vector_cargas; //número de carga de cada ciudad

//Vamos a realizar el cálculo de los kilómetros de cada camiones
km km_camiones(const GrafoP<km> &G, const vector_carga &cargas, vertice capital){
  //Vamos a crearnos el vector de vértices para hacer Dijkstra
  std::vector<vertice>P;
  std::vector<km> km_ida = Dijkstra(G,capital,P);
  std:vector<km> km_vuelta = DijkstraInv(G,capital,P);
  km total_km = 0;

  //Vamos a sumar el número de km para obtener cuantos hacen
  for(size_t i = 0; i < cargas.size(); i++){
    total_km += (ida[i] + vuelta[i]) * cargas[i];
  }
  return total_km;
}
\end{minted}

\textbf{\large\underbar{Ejercicio 5:}}\textit{ Se dispone de tres grafos que representan la matriz de costes para viajes en un determinado país pero por diferentes medios de transporte, por supuesto todos los grafos tendrán el mismo número de nodos. El primer grafo representa los costes de ir por carretera, el segundo en tren y el tercero en avión. Dado un viajero que dispone de una determinada cantidad de dinero, que es alérgico a uno de los tres medios de transporte, y que sale de una ciudad determinada, implementar un subprograma que determine las ciudades a las que podría llegar nuestro infatigable viajero.}

Para empezar tenemos 3 grafos que representan 3 maneras diferentes de transportarse. Sabemos que tenemos una ciudad origen donde se empieza el viaje y que el viajero es alérgico a uno de los medios de transporte (a uno de los 3 grafos).

Sabiendo esto, tenemos que devolver las ciudades a las que puede viajar el viajero.

Haremos uso de Dijkstra para hacer este ejercicio, ya que contamos con una ciudad origen.
\begin{minted}[breaklines]{C++}
//Definimos los tipos de datos a usar
typedef GrafoP<size_t>::vertice vertice;

//Como tenemos 3 grafos (3 medios de transporte), podemos hacer un super grafo y rellenarlo, para poder trabajar más comodamente.
void rellena_supergrafo(const GrafoP<size_t> &trans1, const GrafoP<size_t> &trans2, const GrafoP<size_t> &supergrafo){
  for(vertice v = 0; v < trans1.numVert(); v++)
    for(vertice w = 0; w < trans2.numVert(); w++){
      supergrafo[v][w] = std::min(trans1[v][w],trans2[v][w]);
    }
}

//Como tenemos que devolver las ciudades a las que puede ir nuestro viajero alérgico vamos a crear un método que nos devuelva en un vector dichas ciudades.

std::vector<bool> ciudades_alcanzables(const GrafoP<size_t> &carretera, const GrafoP<size_t> &tren, const GrafoP<size_t> &avion, const string alergia, vertice origen, size_t presupuesto){
  //Nos creamos el supergrafo
  GrafoP<size_t> G(G.numVert());
  //Vamos a crearnos el vector que nos dirá a que ciudades podemos importa
  std::vector<bool> alcanzables(G.numVert(),false);
  //Nos creamos los vectores para hacer Dijkstra
  std::vector<vertice> P(G.numVert());
  std::vector<size_t> costes_minimos(G.numVert());

  //Ahora vamos a rellenar el supergrafo dependiendo de la alergia que tenga
  if(alergia == "carretera")
    rellena_supergrafo(tren,avion,G);
  else if(alergia == "tren")
    rellena_supergrafo(carretera,avion,G);
  else if(alergia == "avion")
    rellena_supergrafo(carretera,tren,G);
  //else si la string no es una de esas alergias no hace nada.

  //Calculamos los costes mínimo
  costes_minimos = Dijkstra(G,origen,P);

  //Ahora vamos a quedarnos con las ciudades a las que puede ir el viajero
  for(vertice i = 0; i < costes_minimos.size(); i++){
    if(costes_minimos[i] <= presupuesto)
      alcanzables[i] = true;
  }

  //Ahora ponemos la ciudad origen como alcanzable
  alcanzables[origen] = true;

  //devolvemos las ciudades a las que puede ir el viajero
  return alcanzables;
}
\end{minted}

\textbf{\large\underbar{Ejercicio 6:}}\textit{ Al dueño de una agencia de transportes se le plantea la siguiente situación. La agencia de viajes ofrece distintas trayectorias combinadas entre N ciudades españolas utilizando tren y autobús. Se dispone de dos grafos que representan los costes (matriz de costes) de viajar entre diferentes ciudades, por un lado en tren, y por otro en autobús (por supuesto entre las ciudades que tengan línea directa entre ellas). Además coincide que los taxis de toda España se encuentran en estos momentos en huelga general, lo que implica que sólo se podrá cambiar de transporte en una ciudad determinada en la que, por casualidad, las estaciones de tren y autobús están unidas.}

\textit{Implementa una función que calcule la tarifa mínima (matriz de costes mínimos) de viajar entre cualesquiera de las N ciudades disponiendo del grafo de costes en autobús, del grafo de costes en tren, y de la ciudad que tiene las estaciones unidas.}

Vemos que tenemos dos medios de transporte (tren y bus) para viajar entre distintas ciudades. Estos dos medios de transporte son dos grafos que tienen el mismo número de vértices.
Los viajes los podemos realizar de varias maneras:
\begin{itemize}
  \item Viaje entero en bus.
  \item Viaje entero en tren.
  \item Tren \(\rightarrow\) ciudad transbordo \(\rightarrow\) bus.
  \item Bus \(\rightarrow\) ciudad transbordo \(\rightarrow\) tren.
\end{itemize}

Encontramos 4 maneras diferentes de realizar un viaje debido a que no nos obligan cambiar de medio de transporte.

Para calcular la tarifa mínima, vamos a hacer uso de Floyd, ya que no tenemos un origen definido, si no una ciudad donde se puede hacer transbordo, por tanto haremos Floyd para cada medio de transporte.

\begin{minted}[breaklines]{C++}
//Definimos los tipos de datos a usar
typedef size_t coste;
typedef GrafoP<coste>::vertice vertice; //Equivale a una ciudad del Grafo

//Vamos a obtener la matriz de costes mínimos de realizar los viajes
matriz<coste> tarifa_minima(const GrafoP<coste> &Tren, const GrafoP<coste> &Bus, vertice ctransbordo){
  //Creamos el supergrafo
  matriz<vertice> M(Tren.numVert());
  //Realizamos Floyd para calcular los costes mínimos de cada grafo dado
  matriz<coste> matriz_minima_bus = Floyd(Bus,M);
  matriz<costa> matriz_minima_tren = Floyd(Tren, M);
  matriz<coste> tarifa(Tren.numVert());

  //Ahora vamos a rellenar la matriz de las tarifas minimas
  for(size_t i = 0; i < tarifa.dimension(); i++)
    for(size_t j = 0; j < tarifa.dimension(); j++){
      coste bus_tren = matriz_minima_bus[i][ctransbordo] + matriz_minima_tren[ctransbordo][j];
      coste tren_bus = matriz_minima_tren[i][ctransbordo] + matriz_minima_bus[ctransbordo][j];
      tarifa[i][j] = std::min(std::min(matriz_minima_tren[i][j],matriz_minima_bus[i][j]),std::min(matriz_minima_bus[i][j], matriz_minima_tren[i][j]));
    }
    return tarifa;
}
\end{minted}

\textbf{\large\underbar{Ejercicio 7:}}\textit{ Se dispone de dos grafos (matriz de costes) que representan los costes de viajar entre N ciudades españolas utilizando el tren (primer grafo) y el autobús (segundo grafo). Ambos grafos representan viajes entre las mismas N ciudades.}

\textit{Nuestro objetivo es hallar el camino de coste mínimo para viajar entre dos ciudades concretas del grafo, origen y destino, en las siguientes condiciones:
\begin{itemize}
  \item La ciudad origen sólo dispone de transporte por tren.
  \item La ciudad destino sólo dispone de transporte por autobús.
  \item El sector del taxi, bastante conflictivo en nuestros problemas, sigue en huelga,
  por lo que únicamente es posible cambiar de transporte en dos ciudades del grafo, cambio1 y cambio2, donde las estaciones de tren y autobús están unidas.
\end{itemize}
Implementa un subprograma que calcule la ruta y el coste mínimo para viajar entre las ciudades Origen y Destino en estas condiciones.}

Partimos de que tenemos 2 Grafos (matriz de coste) para los viajes en tren y en bus, donde ambos tienen el mismo número de vértices.

Ahora nos obligan a que el viaje se empieza en tren y termina en bus, por tanto, nos obligan a hacer un transbordo.

Es decir, nuestros viajes serían:
\begin{itemize}
  \item Tren(origen) → transbordo(ciudad cambio1) → Bus(destino).
  \item Bus(destino) → transbordo(ciudad cambio2) → Tren(origen).
\end{itemize}

Como tenemos un origen, haremos uso de Dijkstra y como tenemos un destino haremos DijkstraInv.

Donde el coste mínimo de viajar desde la ciudad Origen a Destino es el mínimo de las dos opciones vistas anteriormente.

\begin{minted}[breaklines]{C++}
size_t ViajeTren_Bus(const GrafoP<size_t> &Tren, GrafoP<size_t> &Bus, size_t origen, size_t destino, size_t cambio1, size_t cambio2){
  //Creamos los vectores (vértices y coste minimo) para hacer uso de Dijkstra e DijkstraInv
  vector<size_t> CosteTren;
  vector<size_t> CosteBus;
  vector<size_t> VerticesTren;
  vector<size_t> VerticesBus;

  CosteTren = Dijkstra(Tren,origen,VerticesTren);
  CosteBus = DijkstraInv(Bus,destino,VerticesBus);

  //nos creamos dos "ciudades" que serán representadas con dos enteros
  size_t ciudad1 = CosteTren[cambio1]+CosteBus[cambio1];
  size_t ciudad2 = CosteTren[cambio2]+CosteBus[cambio2];
  return std::min(ciudad1,ciudad2);
}
\end{minted}

\textbf{\large\underbar{Ejercicio 8:}}\textit{ “UN SOLO TRANSBORDO, POR FAVOR”. Este es el título que reza en tu flamante compañía de viajes. Tu publicidad explica, por supuesto, que ofreces viajes combinados de TREN y/o AUTOBÚS (es decir, viajes en tren, en autobús, o usando ambos), entre N ciudades del país, que ofreces un servicio inmejorable, precios muy competitivos, y que garantizas ante notario algo que no ofrece ninguno de tus competidores: que en todos tus viajes COMO MÁXIMO se hará un solo transbordo (cambio de medio de transporte).}

\textit{Bien, hoy es 1 de Julio y comienza la temporada de viajes.\\
¡Qué suerte! Acaba de aparecer un cliente en tu oficina.\\ Te explica que quiere viajar entre dos ciudades, Origen y Destino, y quiere saber cuánto le costará.\\
Para responder a esa pregunta dispones de dos grafos de costes directos (matriz de costes) de viajar entre las N ciudades del país, un grafo con los costes de viajar en tren y otro en autobús.\\
Implementa un subprograma que calcule la tarifa mínima en estas condiciones. Mucha suerte en el negocio, que la competencia es dura.}

Como en el ejercicio anterior, contamos con 2 grafos que representan los costes de ir en tren y bus, además contamos con dos ciudades, una de origen del viaje y la destino del mismo.

En este ejercicio vemos que los viajes pueden ser o no combinados, es decir, nuestros viajes son:
\begin{itemize}
  \item Viaje1: Todo en Tren → Dijkstra(tren).
  \item Viaje2: Todo en Bus  → Dijkstra(bus).
  \item Viaje3: Empiezo con Tren y termino con Bus  → Dijkstra(tren) + DijkstraInv(bus).
  \item Viaje4: Empiezo con Bus y termino con Tren  → Dijkstra(bus) + DijkstraInv(tren).
\end{itemize}

Por tanto, la tarifa mínima será el menor coste de estas 4 opciones:
\begin{minted}[breaklines]{C++}
size_t ViajeTren_Bus2(const GrafoP<size_t> &Tren, const GrafoP<size_t> &Bus, size_t origen, size_t destino){
  //Vamos a crear los vectores (vértices y costes) para realizar Dijkstra y DijkstraInv.
  vector<size_t> VerticesTren;
  vector<size_t> VerticesBus;
  vector<size_t> CostesMinimosTren = Dijkstra(Tren,origen,VerticesTren);
  vector<size_t> CostesMinimosBus = Dijkstra(Bus,origen,VerticesBus);
  //ahora vamos a calcular los costes para las 4 opciones de viaje:
  size_t viaje1 = CostesMinimosTren[destino],
         viaje2 = CostesMinimosBus[destino];
  size_t viaje3, viaje4;
  for(size_t i = 0; i < Tren.numVert(); i++){
    viaje3 = CostesMinimosTren[origen] + DijkstraInv(Bus,destino,VerticesBus)[destino];
    viaje4 = CostesMinimosBus[origen] + DijkstraInv(Tren,destino,VerticesTren)[destino];
  }
  //Devolvemos el mínimo de los 4:
  return std::min(viaje1,viaje2,viaje3,viaje4);
}
\end{minted}

\textbf{\large\underbar{Ejercicio 9:}}\textit{ Se dispone de dos grafos que representan la matriz de costes para viajes en un determinado país, pero por diferentes medios de transporte (tren y autobús, por ejemplo). Por supuesto ambos grafos tendrán el mismo número de nodos, N. Dados ambos grafos, una ciudad de origen, una ciudad de destino y el coste del taxi para cambiar de una estación a otra dentro de cualquier ciudad (se supone constante e igual para todas las ciudades), implementa un subprograma que calcule el camino y el coste mínimo para ir de la ciudad origen a la ciudad destino.}

Ahora contamos de nuevo con los dos grafos (costes de ir en tren y bus), la ciudades origen y destino del viaje, pero ahora tenemos un coste adicional que sería el taxi que nos permite cambiarnos de medio de transporte.

Nuestros viajes quedan de la forma:
\[
\begin{array}{c|c|c}
      & \textbf{TREN} & \textbf{BUS} \\
      \hline
\textbf{TREN} & \text{GRAFO TREN} & \text{DIAGONAL TAXI} \\
      \hline
\textbf{BUS}  & \text{DIAGONAL TAXI} & \text{GRAFO BUS} \\
\end{array}
\]

Donde el primer cuadrante, sería el grafo del tren, segundo y tercer cuadrante en su diagonal se pondría el coste del taxi y en el cuarto cuadrante estaría el grafo del bus.

Ahora tendríamos los siguientes viajes:
\begin{itemize}
  \item Viaje1: Todo en Tren → Dijkstra(origenTren)[destinoTren].
  \item Viaje2: Tren-Bus → Dijkstra(origenTren)[destinoBus].
  \item Viaje3: Todo Bus → Dijkstra(origenBus)[destinoBus].
  \item Viaje4: Bus-Tren → Dijkstra(origenBus)[destinoTren].
\end{itemize}

Esto lo podemos hacer haciendo un supergrafo, que nos dará como resultado la matriz anterior.

\begin{minted}[breaklines]{C++}
//Vamos a crearnos un método que calcule el mínimo de los 4 viajes:
size_t minimo (size_t a, size_t b, size_t c, size_t d){
  size_t minimo = a;
  typedef GrafoP<size_t>::INFINITO INFINITO;
  if(b != INFINITO && b < minimo)
     minimo = b;
  if(c != INFINITO && c < minimo)
    minimo = c;
  if( d != INFINITO && d < minimo)
    minimo = d;
  return minimo;
}
//Definimos los tipos de datos a usar
typedef std::pair<vector<size_t>, size_t> CaminoCosteViaje;

CaminoCosteViaje Viaje(const GrafoP<size_t> &Tren, const GrafoP<size_t> &Bus, size_t origen, size_t destino, size_t costeTaxi){
  //Creamos el supergrafo de tamaño 2*N
  GrafoP<size_t> G(2*Tren.numVert());
  //Rellenamos el supergrafo:
  for(size_t i = 0; i < Tren.numVert(); i++)
    for(size_t j = 0; j < Tren.numVert(); j++){
      if(i < Tren.numVert() && j < Tren.numVert()){ //Primer cuadrante
        G[i][j] = Tren[i][j];
      }
      //Segundo y Tercer cuadrante
      else if(i < Tren.numVert() && j >= Tren.numVert() || i >= Tren.numVert() && j < Tren.numVert()){
        //Solamente tiene coste las diagonales (Donde se encuentran un Tren con un Bus)
        if(i + Tren.numVert() == j || i == Tren.numVert() + j){
          G[i][j] = costeTaxi;
        }
        else{
          G[i][j] = GrafoP<size_t>::INFINITO;
        }
      }
      else{//Cuarto cuadrante
        G[i][j] = Bus[i - Tren.numVert()][j - Tren.numVert()];
      }
    }
  //Ahora que tenemos relleno el supergrafo, vamos a calcular los costes minimos de los viajes
  //Primero creamos los vectores (vertices y costes) para hacer Dijkstra
  vector<size_t> CostesMinimosTren;
  vector<size_t> CostesMinimosBus;
  vector<size_t> VerticesTren;
  vector<size_t> VerticesBus;
  size_t COT = origen; //Ciudad Origen Tren
  size_t CDT = destino; //Ciudad Destino Tren
  size_t COB = origen + tren.numVert(); //Ciudad Origen Bus
  size_t CDB = destino + tren.numVert(); //Ciudad Destino Bus


  //Hacemos Dijkstra con el Grafo de Tren
  CostesMinimosTren = Dijkstra(Tren,COT,VerticesTren);
  CostesMinimosBus = Dijkstra(Bus,COB, VerticesBus);

  //Calculamos los 4 viajes diferentes
  size_t viaje1 = CostesMinimosTren[CDT];
  size_t viaje2 = CostesMinimosTren[CDB];
  size_t viaje3 = CostesMinimosBus[CDB];
  size_t viaje4 = CostesMinimosBus[CDT];

  //Ahora nos quedamos con el mínimo de los 4
  size_t viaje = minimo(viaje1,viaje2,viaje3,viaje4);

  //Obtenemos el camino para poder devolverlo
  vector<size_t> verticesCamino = (viaje == viaje1|| viaje == viaje2) ? VerticesTren : VerticesBus;
  size_t i = (viaje == viaje1 || viaje == viaje3) ? CDT : CDB;
  //Creamos el vector
  vector<size_t> camino;
  while(i != origen){
    camino.push_back(i);
    i = verticesCamino[i];
  }
  //Guardamos el origen y le damos la vuelta al vector
  camino.push_bac(origen);
  camino.reverse(camino.size());
  return{camino,viaje};
}
\end{minted}

\textbf{\large\underbar{Ejercicio 10:}}\textit{ Se dispone de tres grafos que representan la matriz de costes para viajes en un determinado país, pero por diferentes medios de transporte (tren, autobús y avión). Por supuesto los tres grafos tendrán el mismo número de nodos, N.}

\textit{Dados los siguientes datos:
  \begin{itemize}
    \item los tres grafos,
    \item una ciudad de origen,
    \item una ciudad de destino,
    \item el coste del taxi para cambiar, dentro de una ciudad, de la estación de tren a la
de autobús o viceversa (taxi-tren-bus) y
    \item el coste del taxi desde el aeropuerto a la estación de tren o la de autobús, o
viceversa (taxi-aeropuerto-tren/bus)
  \end{itemize}
  y asumiendo que ambos costes de taxi (distintos entre sí, son dos costes diferentes) son constantes e iguales para todas las ciudades, implementa un subprograma que calcule el camino y el coste mínimo para ir de la ciudad origen a la ciudad destino.
}

En este ejercicio contamos ahora con 3 grafos (tren, bus y avión), que representan las 3 maneras de poder viajar entre ciudades de un mismo país, también contamos con la ciudad origen y destino del viaje y a diferencia de otros ejercicios tenemos el coste del taxi que nos lleva desde el aeropuerto a una estación de tren o bus, o viceversa y el coste del taxi de ir de una estación de tren a una de bus y viceversa.

Por tanto, para realizar este ejercicio, podemos hacer un supergrafo del tamaño 3*N para poder calcular los viajes que se pueden hacer en dicho país, para ello haremos uso de Dijkstra ya que tenemos una ciudad origen y un destino, sean los viajes posibles:
\begin{itemize}
  \item Viaje1: Todo Tren \(\rightarrow\) Dijkstra(Origentren)[DestinoTren]
  \item Viaje2: Tren-Bus \(\rightarrow\) Dijkstra(OrigenTren)[DestinoBus]
  \item Viaje3: Tren-avion \(\rightarrow\) Dijkstra(OrigenTren)[DestinoAvion]
  \item Viaje4: Todo Bus \(\rightarrow\) Dijkstra(OrigenBus)[DestinoBus]
  \item Viaje5: Bus-Tren \(\rightarrow\) Dijkstra(OrigenBus)[DestinoTren]
  \item Viaje6: Bus-Avion \(\rightarrow\) Dijkstra(OrigenBus)[DestinoAvion]
  \item Viaje7: Todo Avion \(\rightarrow\) Dijkstra(OrigenAvion)[DestinoAvion]
  \item Viaje8: Avion-Tren \(\rightarrow\) Dijkstra(OrigenAvion)[DestinoTren]
  \item Viaje9: Avion-Bus \(\rightarrow\) Dijkstra(OrigenAvion)[DestinoBus]
\end{itemize}

Finalmente, nuestra matriz (supergrafo) quedaría:

\[
\begin{array}{c|c|c|c}
      & \textbf{TREN} & \textbf{BUS} & \textbf{AVION}  \\
      \hline
\textbf{TREN} & \text{GRAFO TREN} & \text{TAXI TREN-BUS} & \text{TAXI TREN-AVION} \\
      \hline
\textbf{BUS}  & \text{TAXI BUS-TREN} & \text{GRAFO BUS} & \text{TAXI BUS-AVION} \\
      \hline
\textbf{AVION} & \text{TAXI AVION-TREN} & \text{TAXI AVION-BUS} & \text{GRAFO AVION}
\end{array}
\]

\begin{minted}[breaklines]{C++}
//Definimos el tipo de dato que vamos a devolver
typedef std::pair<vector<vertice>,size_t> CosteViaje;

//Función auxiliar:
size_t minimo (size_t a, size_t b, size_t c, size_t d , size_t e, size_t f, size_t g, size_t h, size_t i){
  size_t min = a;
  typedef GrafoP<size_t>::INFINITO Infinito;
  if(b != Infinito && b < min)
    min = b;
  if(c != Infinito && c < min)
    min = c;
  if(d != Infinito && d < min)
    min = d;
  if(e != Infinito && e < min)
    min = e;
  if(f != Infinito && f < min)
    min = f;
  if(g != Infinito && g < min)
    min = g;
  if(h != Infinito && h < min)
    min = h;
  if(i != Infinito && i < min)
    min = i;
  return min;
}

CosteViaje Viaje(GrafoP<size_t> &Tren, GrafoP<size_t> &Bus, GrafoP<size_t> &Avion, size_t Origen, size_t Destino, size_t CTaxi, size_t CTaxiAeropuerto){
  //Primero de todos creamos el supergrafo y lo rellenamos
  GrafoP<size_t> S(3*Tren.numVert());

  for(size_t i = 0; i < S.numVert(); i++){
    for(size_t j = 0; j < S.numVert(); j++){
      if(i < Tren.numVert() && j < Tren.numVert()){ //1º cuadrante
        S[i][j] = Tren[i][j];
      }
      else if(i < Tren.numVert() && j >= Tren.numVert() && j < 2*Tren.numVert()){ //2º Cuadrante
        //Solamente se rellena la diagonal, si no infinito
        if(j - Tren.numvert() == i){
          S[i][j] = CTaxi;
        }else{
          S[i][j] = GrafoP<size_t>::INFINITO;
        }
      }
      else if(i < Tren.numVert() && j >= 2*Tren.numVert()){ //3º Cuadrante
        //Solamente se rellena la diagonal, si no infinito
        if(i == j - 2*Tren.numVert()){
          S[i][j] = CTaxiAeropuerto;
        }
        else{
          S[i][j] = GrafoP<size_t>::INFINITO;
        }
      }
      else if(i >= Tren.numVert() && i < 2*Tren.numVert() && j < Tren.numVert()){ //4º Cuadrante
        //Solamente se rellena la diagonal, si no infinito
        if(j == i - Tren.numVert()){
          S[i][j] = CTaxi;
        }
        else{
          S[i][j] = GrafoP<size_t>::INFINITO;
        }
      }
      else if(i >= Tren.numVert() && i < 2*Tren.numVert() && (j >= Tren.numVert() && j < 2*Tren.numVert())){
        //5º Cuadrante
        S[i][j] = Bus[i-Tren.numVert()][j-Tren.numVert()];
      }
      else if(i >= Tren.numVert() && i < 2*Tren.numVert() && j > 2*Tren.numVert()){ //6º Cuadrante
        //Solamente se rellena la diagonal, si no infinito
        if(i - Tren.numVert() == j - 2*Tren.numVert()){
          S[i][j] = CTaxi;
        }
        else{
          S[i][j] = GrafoP<size_t>::INFINITO;
        }
      }
      else if(i >= 2*Tren.numVert() && j < Tren.numVert() ){//7º Cuadrante
        //Solamente se rellena la diagonal, si no infinito
        if(i - 2*Tren.numVert() == j){
          S[i][j] = CTaxiAeropuerto;
        }
        else{
          S[i][j] = GrafoP<size_t>::INFINITO;
        }
      }
      else if(i >= 2*Tren.numVert() && j >= Tren.numVert() && j < 2*Tren.numVert()){//8º Cuadrante
        //Solamente se rellena la diagonal, si no infinito
        if(i - 2*Tren.numVert() == j - Tren.numVert()){
          S[i][j] = CTaxiAeropuerto;
        }
        else{
          S[i][j] = GrafoP<size_t>::INFINITO;
        }
      }
      else{ //9º Cuadrante
        S[i-2*Tren.numVert()][j-2*Tren.numVert()] = Avion[i][j];
      }
    }
  }
  //Ya rellenado el supergrado, podemos realizar el cálculo de los costes mínimos, para ello creamos los vectores(coste y vértices) para realizar Dijkstra.


  //Dijkstra desde Ciudad Origen Tren
  vector<size_t>VerticesTren;
  size_t OrigenTren = Origen;
  size_t DestinoTren = Destino;
  vector<size_t>CostesMinimosTren = Dijkstra(S,OrigenTren,VerticesTren);

  //Dijkstra desde ciudad Origen Bus
  vector<size_t>VerticesBus;
  size_t OrigenBus = Origen + Tren.numVert();
  size_t DestinoBus = Destino + Tren.numVert();
  vector<size_t>CostesMinimosBus = Dijkstra(S,OrigenBus,VerticesBus);

  //Dijkstra desde ciudad Origen Avion
  vector<size_t> VerticesAvion;
  size_t OrigenAvion = Origen + 2*Tren.numVert();
  size_t DestinoAvion = Destino + 2*Tren.numVert();
  vector<size_t> CostesMinimosAvion = Dijkstra(S,OrigenAvion,VerticesAvion);



  //Vamos a calcular el camino más corto (menor coste):
  //---Viajes OrigenTren---
  size_t viaje1 = CostesMinimosTren[DestinoTren];
  size_t viaje2 = CostesMinimosTren[DestinoBus];
  size_t viaje3 = CostesMinimosTren[DestinoAvion];

  //---Viajes OrigenBus---
  size_t viaje4 = CostesMinimosBus[DestinoBus];
  size_t viaje5 = CostesMinimosBus[DestinoTren];
  size_t viaje6 = CostesMinimosBus[DestinoAvion];

  //---Viajes OrigenAvion---
  size_t viaje7 = CostesMinimosAvion[DestinoAvion];
  size_t viaje8 = CostesMinimosAvion[DestinoTren];
  size_t viaje9 = CostesMinimosAvion[DestinoBus];

  //Ahora nos vamos a quedar con el mínimo de los 9 viajes posibles.
  size_t viajeminimo = minimo(viaje1,viaje2,viaje3,viaje4,viaje5,viaje6,viaje7,viaje8,viaje9);

  //Vamos a obtener el camino del viaje minimo.
  vector<size_t>verticescamino = (viajeminimo == viaje1 || viajeminimo == viaje2 || viajeminimo == viaje3) ? VerticesTren : (viajeminimo == Viaje4 || viajeminimo == viaje5 || viajeminimo == viaje6 )? VerticesBus : VerticesAvion;

  vector<size_t>camino; //camino del viaje minimo
  size_t ciudad = (viajeminimo == viaje1 || viajeminimo == viaje5|| viajeminimo == viaje8) ?DestinoTren : (viajeminimo == viaje2 || viajeminimo == viaje4 || viajeminimo == viaje9) ? DestinoBus : DestinoAvion; //obtenemos el destino

  while(ciudad != Origen){
    camino.push_back(ciudad);
    ciudad = verticescamino[ciudad];
  }
  camino.push_back(origen);
  camino.reverse(camino.size());

  //Devolvemos el camino + el coste
  return{camino,viajecamino};
}
\end{minted}

\textbf{\large\underbar{Ejercicio 11:}}\textit{ Disponemos de tres grafos (matriz de costes) que representan los costes directos de viajar entre las ciudades de tres de las islas del archipiélago de las Huríes (Zuelandia).\\Para poder viajar de una isla a otra se dispone de una serie de puentes que conectan ciudades de las diferentes islas a un precio francamente asequible (por decisión del Prefecto de las Huríes, el uso de los puentes es absolutamente gratuito).}

\textit{Si el alumno desea simplificar el problema, puede numerar las \(N_1\) ciudades de la isla 1, del 0 al \(N_{1}-1\), las \(N_2\) ciudades de la isla 2, del \(N_1\) al \(N_1+N_2-1\), y las \(N_3\) de la última, del \(N_1+N_2\) al \(N_1+N_2+N_3-1\).}

\textit{Disponiendo de las tres matrices de costes directos de viajar dentro de cada una de las islas, y la lista de puentes entre ciudades de las mismas, calculad los costes mínimos de viajar entre cualesquiera dos ciudades de estas tres islas.\\¡¡¡ QUE DISFRUTÉIS EL VIAJE !!!}

Contamos con 3 grafos (3 islas del archipiélago), la lista de puentes de cada isla. Como tenemos 3 grafos podemos hacer uso de un supergrafo (3*N) quedando la matriz de la manera:
\[
\begin{array}{c|c|c|c}
                & \textbf{Isla1}          & \textbf{Isla2}            & \textbf{Isla3}  \\
      \hline
\textbf{Isla1}  & \text{GRAFO ISLA1}      & \text{PUENTES ISLA1-2}    & \text{PUENTES ISLA1-3}\\
      \hline
\textbf{Isla2}  & \text{PUENTES ISLA2-1}  & \text{GRAFO ISLA2}      & \text{PUENTES ISLA2-3} \\
      \hline
\textbf{Isla3}  & \text{PUENTES ISLA3-1}  & \text{PUENTES ISLA3-2}     & \text{GRAFO ISLA3}
\end{array}
\]
Como no contamos ni con un origen ni destino, haremos uso de Floyd, para obtener la matriz de costes minimos.
Una cosa a tener en cuenta son los puentes, que lo vamos a representar como un par de dos ciudades/vértices, además el uso de estos es gratis.
\begin{minted}[breaklines]{C++}
//Definimos los tipos de datos a usar
typedef std::pair<size_t,size_t> puente;

matriz<size_t> ViajesIslas(GrafoP<size_t> &Isla1, GrafoP<size_t> &Isla2, GrafoP<size_t> &Isla3, const vector<puente> &puentes){
  //Creamos el supergrafo
  GrafoP<size_t> S(Isla1.numVert() + Isla2.numVert() + Isla3.numVert());
  //Rellenamos el supergrafo
  for(size_t i = 0; i < S.numVert(); i++){
    for(size_t j = 0; j < S.numVert(); j++){
      //Como no tenemos que incluir el coste de los puentes, solamente buscamos los Cuadrantes de los Grafos, lo demás en infinito (no hay puentes todavia).
      if(i < Isla1.numVert() && j < Isla.numVert()){ //1º Cuadrante
        S[i][j] = Isla1[i][j];
      }
      else if(i >= Isla1.numVert() && i < Isla1.numVert() + Isla2.numVert() && j >= Isla1.numVert() && j < Isla1.numVert() + Isla2.numVert()){//5º Cuadrante
        S[i][j] = Isla2[i - Isla1.numVert()][j - Isla1.numVert()];
      }
      else if(i >= Isla1.numVert() + Isla2.numVert() && j >= Isla1.numVert() + Isla2.numVert()){//9º Cuadrante
        S[i][j] = Isla3[i - Isla1.numVert() - Isla2.numVert()][j - Isla1.numVert() - Isla2.numVert()];
      }
      else{ //no hay puentes todavía
        S[i][j] = GrafoP<size_t>::INFINITO;
      }
    }
  }
  //Una vez relleno el supergrafo, vamos a incluir los puentes.
  for(auto& p : puentes){
    // = 0 significa que hay camino directo.
    G[p.first][p.second] = 0;
    G[p.second][p.first] = 0;
  }

  //Ahora declaramos las matrices (CostesMinimos y vértices) para calcular Floyd.
  matriz<size_t>CostesMinimos,Vertices;
  return CostesMinimos = Floyd(S,Vertices);
}
\end{minted}

\textbf{\large\underbar{Ejercicio 12:}}\textit{ El archipiélago de Grecoland (Zuelandia) está formado únicamente por dos islas, Fobos y Deimos, que tienen \(N_1\) y \(N_2\) ciudades, respectivamente, de las cuales \(C_1\) y \(C_2\) ciudades son costeras (obviamente \(C_1 \leq N_1\) y \(C_2 \leq N_2\)). Se desea construir un puente que una ambas islas. Nuestro problema es elegir el puente a construir entre todos los posibles, sabiendo que el coste de construcción del puente se considera irrelevante. Por tanto, escogeremos aquel puente que minimice el coste global de viajar entre todas las ciudades de las dos islas, teniendo en cuenta las siguientes premisas:
\begin{enumerate}
  \item Se asume que el coste viajar entre las dos ciudades que una el puente es 0.
  \item Para poder plantearse las mejoras en el transporte que implica la construcción de un puente frente a cualquier otro, se asume que se realizarán exactamente el mismo número de viajes entre cualesquiera ciudades del archipiélago. Por ejemplo, se considerará que el número de viajes entre la ciudad \(P\) de Fobos y la \(Q\) de Deimos será el mismo que entre las ciudades \(R\) y \(S\) de la misma isla. Dicho de otra forma, todos los posibles trayectos a realizar dentro del archipiélago son igual de importantes.
\end{enumerate}
Dadas las matrices de costes directos de Fobos y Deimos y las listas de ciudades
costeras de ambas islas, implementa un subprograma que calcule las dos ciudades que unirá el puente.
}

Partimos de que tenemos dos grafos (ambas islas) y dos conjuntos que son las ciudades costeras de cada isla.

Para poder construir el puente que minimice el coste global de viajar podemos calcular primero los costes mínimos de cada isla con floyd y luego quedarnos con el mínimo de ambas islas, construyendo el puente entre esas dos ciudades, donde un puente será un par de dos ciudades de diferentes islas.

\begin{minted}[breaklines]{C++}
//Definimos los tipos de datos a usar
typedef std::pair<size_t, size_t>puente;

puente PuenteFobosDeimos(const GrafoP<size_t> &Fobos, const GrafoP<size_t> &Deimos, const vector<size_t> &costerasFobos, const vector<size_t> &costerasDeimos){
  //Definimos las matrices (Costes y vértices) para hacer uso de floyd
  matriz<size_t>verticesFobos, CostesMinimosFobos, verticesDeimos, CostesMinimosDeimos;
  //Obtenemos los costes mínimos de cada isla.
  CostesMinimosFobos = Floyd(Fobos,verticesFobos);
  CostesMinimosDeimos = Floyd(Deimos,verticesDeimos);

  //La ciudad costera elegida será la mínima de la media de los costes de ir a dichas ciudades costeras.
  size_t CiudadCosteraMinimaFobos = GrafoP<size_t>::INFINITO;
  for(size_t i = 0; i < costerasFobos.size(); i++){//comparamos todas las ciudades costeras con las ciudades del grafo
    size_t media = 0;
    for(size_t j = 0; j < Fobos.numVert(); j++){
      media += Fobos[j][costerasFobos[i]];
    }
    if(media < CiudadCosteraMinimaFobos)
      CiudadCosteraMinimaFobos = costerasFobos[i];
  }

  size_t CiudadCosteraMinimaDeimos = GrafoP<size_t>::INFINITO;
  for(size_t i = 0; i < costerasDeimos.size(); i++){
    size_t media = 0;
    for(size_t j = 0; j < Deimos.numVert(); j++){
      media += Deimos[j][costerasDeimos[i]];
    }
    if(media < CiudadCosteraMinimaDeimos){
      CiudadCosteraMinimaDeimos = costerasDeimos[i];
    }
  }
  //Devolvemos el puente de ambas ciudades costeras que por lo general cuestan menos ir desde cualquier otra ciudad de su isla.
  return {CiudadCosteraMinimaFobos,CiudadCosteraMinimaDeimos};
}
\end{minted}

\textbf{\large\underbar{Ejercicio 13:}}\textit{ El archipiélago de las Huríes acaba de ser devastado por un maremoto de dimensiones desconocidas hasta la fecha. La primera consecuencia ha sido que todos y cada uno de los puentes que unían las diferentes ciudades de las tres islas han sido destruidos. En misión de urgencia las Naciones Unidas han decidido construir el mínimo número de puentes que permitan unir las tres islas. Asumiendo que el coste de construcción de los puentes implicados los pagará la ONU, por lo que se considera irrelevante, nuestro problema es decidir qué puentes deben construirse. Las tres islas de las Huríes tienen respectivamente \(N_1\), \(N_2\) y \(N_3\) ciudades, de las cuales \(C_1\), \(C_2\) y \(C_3\) son costeras (obviamente \(C_1 \leq N_1\) , \(C_2 \leq N_2\) y \(C_3 \leq N_3\)). Nuestro problema es elegir los puentes a construir entre todos los posibles. Por tanto, escogeremos aquellos puentes que minimicen el coste global de viajar entre todas las ciudades de las tres islas, teniendo en cuenta las siguientes premisas:
\begin{enumerate}
  \item Se asume que el coste viajar entre las ciudades que unan los puentes es 0.
  \item La ONU subvencionará únicamente el número mínimo de puentes necesario
  para comunicar las tres islas.
  \item Para poder plantearse las mejoras en el transporte que implica la construcción de
  un puente frente a cualquier otro, se asume que se realizarán exactamente el mismo número de viajes entre cualesquiera ciudades del archipélago. Dicho de otra forma, todos los posibles trayectos a realizar dentro del archipiélago son igual de importantes.
\end{enumerate}
Dadas las matrices de costes directos de las tres islas y las listas de ciudades costeras del archipiélago, implementad un subprograma que calcule los puentes a construir en las condiciones anteriormente descritas.}

Ahora en este ejercicio tenemos 3 grafos (3 islas), el conjunto de las ciudades costeras de cada isla y queremos obtener el conjunto de puentes que podemos construir en el archipiélago.

Como queremos el mínimo número de puentes posibles se elegirá las ciudades costeras cuyo coste medio de ir desde cualquier otra ciudad de la isla sea el menor, es decir, para conseguir esto, vamos a realizar Floyd para cada isla con el fin de tener la matriz de costes mínimos de cada uno y luego seleccionamos la ciudad costera con menor coste de todas.

Un puente, igual que en el ejercicio anterior, será un par de dos ciudades o vértices de dos islas diferentes.

\begin{minted}[breaklines]{C++}
//Definimos los tipos de datos a usar
typedef std::pair<size_t,size_t> puente;

vector<puente> PuentesArchipielago(const GrafoP<size_t> &Isla1, const GrafoP<size_t> &Isla2, const GrafoP<size_t> &Isla3, const vector<size_t> &costerasIsla1, const vector<size_t> &costerasIsla2, const vector<size_t> &costerasIsla3 ){
  //Vamos a declarar las matrices(CostesMinimos y vértices) para poder realizar Floyd.
  matriz<size_t>CostesMinimosIsla1,CostesMinimosIsla2,CostesMinimosIsla3,
                VerticesIsla1,VerticesIsla2,VerticesIsla3;
  CostesMinimosIsla1 = Floyd(Isla1,VerticesIsla1);
  CostesMinimosIsla2 = Floyd(Isla2,VerticesIsla2);
  CostesMinimosIsla3 = Floyd(Isla3,VerticesIsla3);

  //Como hemos dicho antes, tenemos que quedarnos con la ciudad costera cuyo coste medio sea el menor.

  size_t CiudadCosteraMinimaIsla1 = GrafoP<size_t>::INFINITO;
  size_t CiudadCosteraMinimaIsla2 = GrafoP<size_t>::INFINITO;
  size_t CiudadCosteraMinimaIsla3 = GrafoP<size_t>::INFINITO;

  //Obtenemos la costera mínima de Isla1 comparandola con todas las ciudades de la Isla:
  for(size_t i = 0; i < costerasIsla1.size(); i++){
    size_t media = 0;
    for(size_t j = 0; j < Isla1.numVert(); j++){
      media += Isla1[j][costerasIsla1[i]];
    }
    if(media < CiudadCosteraMinimaIsla1){
      CiudadCosteraMinimaIsla1 = costerasIsla1[i];
    }
  }

  //Obtenemos la costera mínima de Isla2 comparandola con todas las ciudades de la Isla:
  for(size_t i = 0; i < costerasIsla2.size(); i++){
    size_t media = 0;
    for(size_t j = 0; j < Isla2.numVert(); j++){
      media += Isla2[j][costerasIsla2[i]];
    }
    if(media < CiudadCosteraMinimaIsla2){
      CiudadCosteraMinimaIsla2 = costerasIsla2[i];
    }
  }
  //Obtenemos la costera mínima de Isla3 comparandola con todas las ciudades de la Isla:
  for(size_t i = 0; i < costerasIsla3.size(); i++){
    size_t media = 0;
    for(size_t j = 0; j < Isla3.numVert(); j++){
      media += Isla3[j][costerasIsla3[i]];
    }
    if(media < CiudadCosteraMinimaIsla3){
      CiudadCosteraMinimaIsla3 = costerasIsla3[i];
    }
  }
  //Obtenidas las ciudades costeras cuyo coste medio es el mínimo, vamos crear los puentes y devolverlos en el vector.
  vector<puente> puentes;
  puentes.push_back({CiudadCosteraMinimaIsla1,CiudadCosteraMinimaIsla2});
  puentes.push_back({CiudadCosteraMinimaIsla1,CiudadCosteraMinimaIsla3});
  puentes.push_back({CiudadCosteraMinimaIsla2,CiudadCosteraMinimaIsla3});

  return puentes; //devolvemos el conjunto de los puentes.
}
\end{minted}
