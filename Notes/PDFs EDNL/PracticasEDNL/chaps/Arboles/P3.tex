En esta práctica vamos a ver como trabajar con el TAD Agen con sus dos representaciones (enlazada y vectorial).

Como cabeceras de la práctica vamos a tener:
\begin{minted}[breaklines]{C++}
  #include <iostream>
  #include "agen.h" //Especificación e implementación de los métodos del TAD.
  #include "agen_E-S.h"
\end{minted}

\textbf{\large\underbar{Ejercicio 1:}}\textit{ Implementa un subprograma que dado un árbol general nos calcule su grado.}

Para saber cual es el grado de un árbol este es el máximo de los grados de los nodos que componen al árbol.
Por tanto, para saber cuales el grado del Agen, tenemos que saber cual es el grado de cada nodo que lo compone y quedarnos con el máximo.

\begin{minted}[breaklines]{C++}
template <typename T> size_t gradoAgen(const Agen<T> &A){
  return gradoAgen_rec(A.raiz(),A);
}
template <typename T> size_t gradoAgen_rec(typename Agen<T>::nodo n, const Agen<T> &A){
  if(n == Agen<T>::NODO_NULO){
    return 0; //el grado de un nodo nulo (no existe nodo) es 0
  }
  else{
    size_t gradoMax = 0; //grado del árbol
    size_t nHijos = 0; //grado del nodo
    typename Agen<T>::nodo aux = A.hijoIzqdo(n);
    //Calculamos el grado del árbol.
    while(aux != Agen<T>::NODO_NULO){
      nHijos++;
      gradoMax = std::max(gradoMax,gradoAgen_rec(aux,A));
      aux = A.hermDrcho(aux);
    }
    return std::max(nHijos,gradoMax);
  }
}
\end{minted}

\textbf{\large\underbar{Ejercicio 2:}}\textit{ Implementa un subprograma que dados un árbol y un nodo dentro de dicho árbol determine la profundidad de éste nodo en el árbol.}

Para calcular la profundidad de un nodo cualquiera en un árbol general, este se va a calcular de la misma forma que en los árboles binarios, ya que lo que tenemos que hacer es partir del nodo en cuestión e ir llamando al padre del mismo hasta llegar a la raiz.

\begin{minted}[breaklines]{C++}
template <typename T> size_t profundidadAgen_rec(typename Agen<T>::nodo n, const Agen<T> &A){
  if(n == A.raiz())
    return 0;
  else
    return 1+profundidadAgen_rec(A.padre(n),A);
}
\end{minted}

\textbf{\large\underbar{Ejercicio 3:}}\textit{ Se define el desequilibrio de un árbol general como la máxima diferencia entre las alturas de los subárboles más bajo y más alto de cada nivel. Implementa un subprograma que calcule el grado de desequilibrio de un árbol general.}

Vamos a suponer que tenemos un método llamado \texttt{alturaAgen()}, el cual nos hará falta para poder calcular el desequilibrio de un árbol general (según la definició de desequilibrio dada).

Para calcular el desequilibrio vamos a recorrer todos los hermanos del hijo del nodo dado, y vamos calculando el desequilibrio máximo mediante la función \texttt{std::max()}.

\begin{minted}[breaklines]{C++}
template <typename T> size_t desequilibrioAgen(const Agen<T> &A){
  return profundidadAgen_rec(A.raiz(),A);
}

template <typename T> size_t desequilibrioAgen_rec(typename Agen<T>::nodo n, const Agen<T> &A){
  if(n == Agen<T>::NODO_NULO){
    return 0;
  }
  else{
    size_t maxDesequilibrio = 0;
    typename Agen<T>::nodo aux = A.hijoIzqdo(n);
    while (aux != Agen<T>::NODO_NULO){
      maxDesequilibrio = std::max(maxDesequilibrio, std::abs(alturaAgen_rec(aux,A) - alturaAgen(A.hermDrcho(aux),A)));

      aux = A.hermDrcho(aux);
    }
    return maxDesequilibrio;
  }
}
\end{minted}

\textbf{\large\underbar{Ejercicio 4:}}\textit{ Dado un árbol general de enteros A y un entero x, implementa un subprograma que realice la poda de A a partir de x. Se asume que no hay elementos repetidos en A.}

Una poda significa que apartir de dicho nodo tenemos que eliminar todos sus desecendientes y a él mismo.

Para ello, primero tenemos que realizar la búsqueda del elemento `x' en el Agen y a partir de su posición eliminar todos los desecendientes.

\begin{minted}[breaklines]{C++}
//Método buscar un nodo a partir de su contenido
template <typename T> typename Agen<T>::nodo buscar(T e, Agen<T> &A){
  return buscar_rec(e,A.raiz(),A);
}
template <typename T> typename Agen<T>::nodo buscar_rec(T e, typename Agen<T>::nodo n, Agen<T> &A){
  if(n==Agen<T>::NODO_NULO){
    return Agen<T>::NODO_NULO;
  }
  else if(A.elemento(n) == e){ //Lo hemos encontrado, lo devolvemos
    return n;
  }
  else{
    //Vamos a buscar en sus hermanos
    typename Agen<T>::nodo aux = A.hijoIzqdo(n);
    while(aux != Agen<T>::NODO_NULO){
      typename Agen<T>::nodo aux2 = buscar_rec(e,aux,A);
      if(aux2 != Agen<T>::NODO_NULO){
        return aux2;
      }
      aux = A.hermDrcho(aux);

    }
    return Agen<T>::NODO_NULO; //no existe entre los hermanos
  }
}

template <typename T> void podaAgen(T x, Agen<T> &A){
  typename Agen<T>::nodo n = buscar(x,A);
  return podaAgen_rec(n,A);
}

template <typename T> void podaAgen_rec(typename Agen<T>::nodo n, Agen<T>: &A){
  if(n != Agen<T>::NODO_NULO){
    //Mientras que n tenga hijos, podamos
    while(A.hijoIzqdo(n)!= Agen<T>::NODO_NULO){
      //Realizamos la llamada recursiva con el hijo (poda del subárbol del hijo)
      podaAgen_rec(A.hijoIzqdo(n),A);
      A.eliminarHijoIzqdo(n); //eliminamos al propio hijo
    }
  }
}
\end{minted}
