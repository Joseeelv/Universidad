Esta es una práctica de repaso de árboles binarios, es decir, de las prácticas 1 y 2.

\textbf{\large\underbar{Ejercicio 1:}}\textit{ Considere un árbol A, en el que puede suponer que no hay elementos repetidos. Dado un elemento x, devuelve el camino que existe entre la raíz y el nodo cuyo elemento es x, si existe.}

\begin{minted}[breaklines]{C++}
template <typename T> std::vector<T> camino(Abin<T> &A, const T& e){
  //Nos creamos el vector
  std::vector<T> camino_;
  if(!A.arbolVacio()){
    if(buscar_elemento(A.raiz(),A,e,camino_))
      std::reverse(camino_.begin(), camino_.end());
  }
    return camino_;
}
template <typename T> bool buscar_elemento(typename Abin<T>::nodo n, Abin<T> &A,const T& e, vector<T> &v){
  if(n != Abin<T>::NODO_NULO){
    if(A.elemento(n) == e){ //elemento encontrado, metemos en el vector, todos los nodos que lo preceden
      while(n != A.raiz()){
        v.push_back(A.elemento(n));
        n = A.padre(n);
      }
      v.push_back(A.elemento(A.raiz()));
      return true; //devolvemos true cuando hemos terminado de rellenar el camino
    }
    else{
      //Seguimos buscando
      return buscar_elemento(A.hijoIzqdo(n),A,e,v) && buscar_elemento(A.hijoDrcho(n),A,e,v);
    }
  }
  return false; //no existe el elemento en el árbol
}

\end{minted}

\textbf{\large\underbar{Ejercicio 2:}}\textit{ Implementa una función que, dado un árbol , devuelva el número de nodos prósperos que existen en él. Se considera que un nodo es próspero si es estrictamente más rico que sus ascendientes, pero menos rico que sus descendientes.}

\begin{minted}[breaklines]{C++}
template <typename T> size_t esProspero(const Abin<T> &A){
  return esProspero_rec(A.raiz(),A);
}

//Creamos un método auxiliar que compruebe si es más rico que todos sus ascendientes
template <typename T> bool MasRico(typename Abin<T>::nodo n, const Abin<T> &A){
  if(n == Abin<T>::NODO_NULO && A.padre(n) == Abin<T>::NODO_NULO) return false; //No existe el nodo en el árbol, ni su padre
  else{
    if(A.elemento(n) > A.elemento(A.padre(n)))
      return MasRico(A.padre(n),A);
    else return false;
  }
}

//Creamos un método auxiliar que compruebe si es menos rico que todos sus descendientes
template <typename T> bool MenosRico(typename Abin<T>::nodo n, const Abin<T> &A){
  if(n == Abin<T>::NODO_NULO) return 0; //nodo no existe
  else{
    if(A.elemento(n) < A.elemento(A.hijoIzqdo(n)) && A.elemento(n) < A.elemento(A.hijoDrcho(n)))
      return MenosRico(A.hijoIzqdo(n),A) && MenosRico(A.hijoDrcho(n),A);
    else
      return false;
  }
}

template <typename T> size_t esProspero_rec(typename Abin<T>::nodo n, const Abin<T> &A){
  if(n == Abin<T>::NODO_NULO) return 0;
  else{
    if(MasRico(n,A) && MenosRico(n,A))
      return 1 + esProspero_rec(A.hijoIzqdo(n),A) + esProspero_rec(A.hijoDrcho(n),A);
    else
      return 0 + esProspero_rec(A.hijoIzqdo(n),A) + esProspero_rec(A.hijoDrcho(n),A);
  }
}
\end{minted}

\textbf{\large\underbar{Ejercico 3:}}\textit{ Implemente una función que, dado un árbol A y un elemento T, realice la poda del subárbol cuya raíz tiene por elemento T. Puede suponer que no hay elementos repetidos en el árbol.}

Para poder realizar la poda de un subárbol dado un elemento (no el nodo) tenemos que hacer:
\begin{enumerate}
  \item Buscar el nodo que contenga ese elemento.
  \item Recorrer los subárboles hasta llegar a los nodos hojas.
  \item Eliminar los nodos hojas e ir eliminando sus ascendientes hasta el nodo con el elemento buscado.
  \item Eliminar el nodo con el elemento buscado llamando al padre.
\end{enumerate}

\begin{minted}[breaklines]{C++}
//Creamos los métodos para realizar la búsqueda del nodo
template <typename T> Abin<T>::nodo buscar_elto(const T& elto,const Abin<T> &A){
  //creamos el nodo donde se encuentra el elemento
  typename Abin<T>::nodo resultado = Abin<T>::NODO_NULO; //Lo inicializamos
  if(!A.arbolVacio())
    buscar_elto_rec(elto,A.raiz(),resultado,A);
  return resultado; //contiene el nodo donde se encuentra el elemento, si no existe el elemento, devuelve un nodo nulo.
}
template <typename T> bool buscar_elto_rec(const T& elto, typename Abin<T>::nodo n,typename Abin<T>::nodo &res, const Abin<T> &A){
  if(n != Abin<T>::NODO_NULO){
    if(A.elemento(n) == elto){
      res = n;
      return true;
    }
    return buscar_elto_rec(elto,A.hijoIzqdo(n),res,A) || buscar_elto_rec(elto,A.hijoDrcho(n),res,A);
  }
  return false;
}

//Función auxiliar que nos comprueba si el nodo es una hoja o No
template <typename T> bool EsHoja(typename Abin<T>::nodo n , const Abin<T> &A){
  return (A.hijoIzqdo(n) == Abin<T>::NODO_NULO && A.hijoDrcho(n) == Abin<T>::NODO_NULO);
}

//Vamos a realizar la función de poda
template <typename T> void poda(const T& elto, Abin<T> &A){
  if(!A.arbolVacio()){
    //Tenemos que buscar el nodo donde se encuentra dicho elemento
    typename Abin<T>::nodo n = buscar_elto(elto,A);
    if(n != Abin<T>::NODO_NULO){
      poda_rec(n,A);
      //Ahora tengo que eliminar a dicho nodo, llamando al padre
      typename Abin<T>::nodo padre = A.padre(n);
      if(padre != Abin<T>::NODO_NULO){
        if(n == A.hijoIzqdo(padre))
          A.eliminarHijoIzqdo(padre);
        else if(n == A.hijoDrcho(padre))
          A.eliminarHijoDrcho(padre);
      }else if(n == A.raiz() && EsHoja(n))
        A.eliminarRaiz();
    }
  }
}

template <typename T> void poda_rec(typename Abin<T>::nodo n, Abin<T> &A){
  if(n != Abin<T>::NODO_NULO){
    if(!EsHoja(n)){ //Si no es hoja no lo podemos eliminar, llamamos a sus descendientes
      poda_rec(A.hijoIzqdo(n),A);
      poda_rec(A.hijoDrcho(n),A);
    }
    else{ //Es hoja, eliminamos llamando al padre
      typename Abin<T>::nodo padre = A.padre(n);
      if(padre != Abin<T>::NODO_NULO){
        if(n == A.hijoIzqdo(padre))
          A.eliminarHijoIzqdo(padre);
        else if(n == A.hijoDrcho(padre))
          A.eliminarHijoDrcho(padre);
      }
    }
  }
}

\end{minted}

