Las operaciones del TAD árbol binario permiten insertar y eliminar hojas y nodos internos -> **verdadero**

Al insertar en un Árbol B, si el nuevo elemento no cabe en el nodo que le correspondería, se divide el nodo en dos y se promociona un elemento al nodo padre, y en este caso, se permite que exista algún nodo con un solo elemento, independientemente del mínimo permitido según el orden del árbol -> **verdadero**

El cálculo de la altura de un árbol es de O(n), excepto para los AVL, en cuyo caso el orden del cálculo de la altura es logarítmico -> **falso**

Sea un árbol binario implementado mediante una representación vectorial. La destrucción del árbol binario debe eliminar los nodos uno a uno es postorden -> **verdadero**

En el algoritmo de eliminación de una clave en un árbol B, si dicha clave no está en una hora, se sustituye por su sucesor más inmediato, que se encontrará siempre en el hijo derecho del nodo que contiene la clave a eliminar -> **falso**

En un subárbol de un árbol cualquiera se cumple la siguiente propiedad: en cada nodo la suma de su altura y profundidad es constante y coincide con la profundidad de la hoja más profunda -> **falso**

Los elementos de un APO se obtienen en orden mediante la extracción sucesiva de estos -> **verdadero**

Supongamos un ABB con el elemento x en una hoja cuyo padre tiene el valor y. Entonces, y es el menor elemento mayor que x o bien, y es el mayor elemento menor que x -> **verdadero**

La propiedad de equilibrio de un AVL permite encontrar un elemento en un tiempo de O(log n) en el caso peor -> **verdadero**

La representación vectorial de posiciones relativas es adecuada solamente para arboles parcialmente ordenados -> **verdadero**

Para conseguir que la anchura del árbol B sea menor, me interesa crear nodos con el mayor tamaño posible -> **verdadero**

En la implementación vectorial de árbol binario, que tiene como invariante que se colocan todos los elementos al principio del vector, la inserción es de coste O(1), pero el borrado de coste O(n) -> **verdadero**

Un AVL es ABB y el recíproco es cierto -> **verdadero**

La propiedad de equilibrio de un AVL no implica que su altura sea la mínima posible Todo APO min-max cumple estrictamente con las condiciones que hemos definido para un APO, pero el recíproco no es cierto -> **falso**

La eficiencia espacial de la representación de un árbol binario mediante un vector de posiciones relativas será mayor cuantos más nodos falten en el nivel inferior ->**verdadero**

En un AVL cada nodo tiene un factor de equilibrio de 1 0 o -1 y ello significa que todas las hojas se van a encontrar en el último nivel o en el penúltimo -> **falso**

La propiedad de orden parcial de un APO implica que siempre va a estar equilibrado -> **falso**

Una cola con prioridad mediante un APO permite eliminar el elemento prioritario con un coste O(1) en el caso peor -> **verdadero**

La profundidad del nodo más profundo del árbol es la altura de dicho árbol menos 1 -> **falso**

A partir de los recorridos en PreOrden e InOrden de un árbol general es posible reconstruir el árbol original, si además se conoce el grado del árbol ->**verdadero**

La representación del TAD Árbol general mediante listas de hijos es más ineficiente cuanto más alto es el árbol -> **verdadero**

Todo APO min-max cumple estrictamente con las condiciones que hemos definido para un APO, pero el recíproco no es cierto -> **verdadero**

La propiedad de equilibrio de un AVL no implica que su altura sea la mínima posible -> **falso**

La propiedad de equilibrio de un AVL permite encontrar un elemento en un tiempo de O(log n) en el caso peor -> **verdadero**

En la implementación vectorial de árbol binario, que tiene como invariante que se colocan todos los 1. elementos al principio del vector, la inserción es de coste O(1), pero el borrado de coste O(n) -> **verdadero**

La propiedad de orden parcial de un APO implica que siempre va a estar equilibrado -> **falso**

La profundidad del nodo más profundo del árbol es la altura de dicho árbol menos 1 -> **falso**

A partir de los recorridos en PreOrden e InOrden de un árbol general es posible reconstruir el árbol original,
si además se conoce el grado del árbol -> **verdadero**

La representación del TAD Árbol general mediante listas de hijos es más ineficiente cuanto más alto es el
árbol -> **verdadero**

La propiedad de búsqueda de un ABB permite encontrar un elemento en un tiempo de O(log n) en el caso
peor -> **verdadero**

La eliminación de elemento en un ABB puede llegar a tener un coste O(n) -> **verdadero**

El recorrido en preorden de un ABB determina unívocamente el ABB del que procede -> **verdadero**

Sea x un elemento de un ABB. El sucesor de x se encuentra ascendiendo hacia la raíz hasta encontrar un
nodo (que puede ser el propio x) con hijo derecho y a continuación buscando el menor elemento en el
subárbol derecho -> **verdadero**

Los nuevos elementos en un árbol B se insertan en las hojas y, si es necesario, se reorganiza el árbol -> **verdadero**

En un árbol B de orden m, todos los nodos contienen un mínimo de ⌊𝑚−1/2 ⌋ claves, y un máximo de m-1 -> **verdadero**

La condición de equilibrio no perfecto de un AVL no asegura que la inserción de un elemento se pueda hacer
a un coste de O(log n) en el peor caso -> **falso**

Se define el desequilibrio de un árbol general como la máxima diferencia entre las alturas de los subárboles
más bajo y más alto de cada nivel. Esta definición y la diferencia de longitudes entre la rama más larga y más
corta de dicho árbol son equivalentes -> **falso**

Un árbol completo se puede almacenar muy eficientemente en un vector de posiciones relativas -> **verdadero**

Si un árbol es un APO, tiene un desequilibrio en valor absoluto menor o igual que 1, pero el recíproco no es
cierto -> **falso**

En un subárbol de un árbol cualquiera, tal que todas las hojas del subárbol están en el mismo nivel, se
cumple la siguiente propiedad: en cada nodo la suma de su altura y profundidad es constante y coincide con
la profundidad de las hojas -> **verdadero**

Dados los recorridos en preorden y postorden de un árbol binario se puede reconstruir unívocamente el
árbol original -> **falso**

Al insertar en un Árbol B, si el nuevo elemento no cabe en el nodo que le correspondería, se divide el nodo
en dos y se promociona la mediana al nodo padre, y en el caso de que el árbol conserve su altura, se permite
que existan nodos con menos elementos de la mitad (por defecto) de la capacidad de un nodo -> **falso**

La propiedad de completitud de un APO implica que siempre va a estar equilibrado -> **falso**


