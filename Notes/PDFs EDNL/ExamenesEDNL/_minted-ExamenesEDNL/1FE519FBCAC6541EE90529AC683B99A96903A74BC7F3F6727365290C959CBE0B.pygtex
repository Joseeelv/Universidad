\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream}
\PYG{c+cpf}{\PYGZsh{}include \PYGZdq{}abin.h\PYGZdq{}}

\PYG{c+cpf}{template \PYGZlt{}typename T\PYGZgt{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{FlotarNodos}\PYG{p}{(}\PYG{n}{Abin}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{A}\PYG{p}{)\PYGZob{}}
\PYG{+w}{  }\PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{A}\PYG{p}{.}\PYG{n}{arbolVacio}\PYG{p}{())\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{//llamamos al método flotar}
\PYG{+w}{    }\PYG{n}{FlotarNodos\PYGZus{}rec}\PYG{p}{(}\PYG{n}{A}\PYG{p}{.}\PYG{n}{raiz}\PYG{p}{(),}\PYG{n}{A}\PYG{p}{);}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}
\PYG{+w}{  }\PYG{c+c1}{//Si está vacío no se hace nada}
\PYG{p}{\PYGZcb{}}

\PYG{k}{template}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{FlotarNodos\PYGZus{}rec}\PYG{p}{(}\PYG{k}{typename}\PYG{+w}{ }\PYG{n+nc}{Abin}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}::}\PYG{n}{nodo}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Abin}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{A}\PYG{p}{)\PYGZob{}}
\PYG{+w}{  }\PYG{c+c1}{//Tenemos que comprobar que ni él ni el padre sean nulos.}
\PYG{+w}{  }\PYG{k}{if}\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{Abin}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}::}\PYG{n}{NODO\PYGZus{}NULO}\PYG{+w}{ }\PYG{o}{||}\PYG{+w}{ }\PYG{n}{A}\PYG{p}{.}\PYG{n}{padre}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!=}\PYG{+w}{ }\PYG{n}{Abin}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}::}\PYG{n}{NODO\PYGZus{}NULO}\PYG{p}{)\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{p}{(}\PYG{n}{A}\PYG{p}{.}\PYG{n}{elemento}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{A}\PYG{p}{.}\PYG{n}{elemento}\PYG{p}{(}\PYG{n}{A}\PYG{p}{.}\PYG{n}{padre}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)))\PYGZob{}}
\PYG{+w}{      }\PYG{c+c1}{//Si el elemento de n es mayor, flotamos.}
\PYG{+w}{      }\PYG{n}{T}\PYG{+w}{ }\PYG{n}{elto\PYGZus{}aux}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{A}\PYG{p}{.}\PYG{n}{elemento}\PYG{p}{(}\PYG{n}{n}\PYG{p}{);}
\PYG{+w}{      }\PYG{n}{A}\PYG{p}{.}\PYG{n}{elemento}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{A}\PYG{p}{.}\PYG{n}{elemento}\PYG{p}{(}\PYG{n}{A}\PYG{p}{.}\PYG{n}{padre}\PYG{p}{(}\PYG{n}{n}\PYG{p}{));}
\PYG{+w}{      }\PYG{n}{A}\PYG{p}{.}\PYG{n}{padre}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{elto\PYGZus{}aux}\PYG{p}{;}
\PYG{+w}{      }\PYG{c+c1}{//llamamos a la recursiva con el padre de n}
\PYG{+w}{      }\PYG{n}{FlotarNodos\PYGZus{}rec}\PYG{p}{(}\PYG{n}{A}\PYG{p}{.}\PYG{n}{padre}\PYG{p}{(}\PYG{n}{n}\PYG{p}{),}\PYG{n}{A}\PYG{p}{);}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{//si el elemento del hijo \PYGZlt{} padre, termina}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}
\PYG{+w}{  }\PYG{c+c1}{//si alguno es nulo, no hace nada}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
