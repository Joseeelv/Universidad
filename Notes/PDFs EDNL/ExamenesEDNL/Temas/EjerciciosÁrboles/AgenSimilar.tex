\textbf{\underbar{Enunciado:}}\textit{ Árboles generales similares. Dos árboles generales son similares si tienen la misma estructura y el contenido de sus nodos hojas deben de ser el mismo.}

Para saber si son similares el árbol general tiene que cumplir dos cosas:
\begin{enumerate}
  \item Tiene que tener la misma estructura de ramificación \(\rightarrow\) el nodo a del árbol A y el nodo b del árbol B tienen el mismo número de hijos.
  \item Los nodos hojas de ambos árboles tienen que tener el mismo contenido.
\end{enumerate}

Vamos a craear un programa que nos compruebe ambas cosas.
\begin{minted}[breaklines]{C++}
#include <iostream>
#include "agen.h"

template <typename T>
bool Similares(const Agen<T> &A, const Agen<T> &B){
  //Si ambos tienen solamente un nodo (raiz), diremos que son similares
  if(A.raiz() == Agen<T>::NODO_NULO && B.raiz() == Agen<T>::NODO_NULO)
    return true;
  return Similares_rec(A.raiz(),B.raiz(),A,B);
}

//Función auxiliar que nos calcula el número de hijos que tiene un nodo
template <typename T>
size_t nHijos(typename Agen<T>::nodo n, const Agen<T> &A){
  size_t nhijos = 0;
  if (n == Agen<T>::NODO_NULO)
    return nhijos;
  else{
    //Vamos a recorrer toda la lista de hijos del nodo n
    typename Agen<T>::nodo hijo = A.hijoIzqdo(n);
    while(hijo != Agen<T>::NODO_NULO){
      nhijos++;
      hijo = A.hermDrcho(hijo);
    }
    return nhijos;
  }
}
//Función que nos comprueba si el nodo es una hoja
template <typename T>
bool esHoja(typename Agen<T>::nodo n, const Agen<T> &A){
  return A.hijoIzqdo(n) == Agen<T>::NODO_NULO;
}

template <typename T>
bool Similares_rec(typename Agen<T>::nodo a, typename Agen<T>::nodo b, const Agen<T> &A; const Agen<T> &B){
  //Ahora tenemos que comprobar las diferentes condiciones
  if(a == Agen<T>::NODO_NULO && b == Agen<T>::NODO_NULO) return true;
  else if(a == Agen<T>::NODO_NULO || Agen<T>::NODO_NULO)
    return false; //si existe a pero no b, o viceversa no son similares.
  else if(esHoja(a,A) && esHoja(b,B)){
    //Comprobamos el contenido de las hojas
    if(A.elemento(a) == B.elemento(b)) 
      return true; //mismo elemento
    else return false;
  }
  else{ //no son hojas, vamos a comprobar la ramificación
  //nos creamos una flag que nos devolerá si son similares o no
    bool flag = nHijos(a,A) == nHijos(b,B); //tiene los mismos hijos, true
    while(flag){ //mientra que sean similares, comprobamos los hijos de los hijos
      flag &= Similares_rec(A.hijoIzqdo(a),B.hijoIzqdo(b),A,B); //llamamos con sus hijos
      a = A.hermDrcho(a);
      b = B.hermDrcho(b);
    }
    return flag; //devolvemos si son similares o no.
  }
}
\end{minted}

Como no tenemos un número determinados del árbol general, para la resolución de este ejercicio, hemos hecho uso de la representación enlazada del TAD agen, siendo su parte privada:
\begin{verbatim}
  private:
    struct celda{
      T elto;
      nodo padre, hizq, hder;
      celda(const T& e, nodo p = NODO_NULO): elto(e), padre(p),
        hizq(NODO_NULO), hder(NODO_NULO){}
    };
  nodo r; //nodo raíz del árbol
};
\end{verbatim}

También hemos hecho uso de los métodos públicos del TAD Agen:
\begin{itemize}
  \item \verb |const T& elemento (nodo n)const;|
  \begin{itemize}
    \item \textit{Pre}: El nodo n existe en el árbol.
    \item \textit{Post}: Devuelve el elemento del nodo n.
  \end{itemize}
  \item \verb |nodo raiz()const;|
  \begin{itemize}
    \item \textit{Post}: Devuelve el nodo raiz del árbol, si vacío devuelve \texttt{NODO\_NULO}.
  \end{itemize}
  \item \verb |nodo hijoIzqdo(nodo n)const;|
  \begin{itemize}
    \item \textit{Pre}: El nodo n existe en el árbol.
    \item \textit{Post}: Devuelve el hijo izquierdo del árbol, si no existe devuelve \texttt{NODO\_NULO}.
  \end{itemize}
  \item \verb |nodo hermDrcho(nodo n)const;|
  \begin{itemize}
    \item \textit{Pre}: El nodo n existe en el árbol.
    \item \textit{Post}: Devuelve el hermano derecho del nodo n, si no existe\\ devuelve \texttt{NODO\_NULO}.
  \end{itemize}
\end{itemize}