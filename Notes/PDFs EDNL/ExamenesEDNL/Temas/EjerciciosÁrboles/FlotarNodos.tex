\textbf{\underbar{Enunciado:}}\textit{ Dado un nodo cualquiera flotarlo hasta que se cumpla una condición. Por ejemplo, flotar un nodo hasta que el elemento del mismo sea menor que el de su padre.}

Vamos a implementar un ABB mediante un Abin, para ello vamos a ir recorriendo el árbol binario comparando los elementos de los nodos y ordenándolos.

Como vamos a ir modificando el árbol, este será una referencia no constante y se devolerá por referencia.
\begin{minted}[breaklines]{C++}
#include <iostream
#include "abin.h"

template <typename T>
void FlotarNodos(Abin<T> &A){
  if(!A.arbolVacio()){
    //llamamos al método flotar
    FlotarNodos_rec(A.raiz(),A);
  }
  //Si está vacío no se hace nada
}

template <typename T>
void FlotarNodos_rec(typename Abin<T>::nodo n, Abin<T> &A){
  //Tenemos que comprobar que ni él ni el padre sean nulos.
  if(n != Abin<T>::NODO_NULO || A.padre(n) != Abin<T>::NODO_NULO){
    if(A.elemento(n) > A.elemento(A.padre(n))){
      //Si el elemento de n es mayor, flotamos.
      T elto_aux = A.elemento(n);
      A.elemento(n) = A.elemento(A.padre(n));
      A.padre(n) = elto_aux;
      //llamamos a la recursiva con el padre de n
      FlotarNodos_rec(A.padre(n),A);
    }
    //si el elemento del hijo < padre, termina
  }
  //si alguno es nulo, no hace nada
}
\end{minted}

Para llevar a cabo este ejercicio hemos hecho uso de un árbol binario (ya que no lo especificaba el enunciado) con la representación enlazada, siendo la parte privada del TAD Abin:
\begin{center}
  \begin{verbatim}
  private:
    struct celda{
      T elto;
      nodo padre, hizq, hder;
      celda(const T& e, nodo p = NODO_NULO):elto(e),padre(p),
        hizq(NODO_NULO),hder(NODO_NULO){}
    };
  nodo r; //raíz del árbol
};//fin del TAD
  \end{verbatim}
\end{center}

Además hemos hecho uso de los métodos públicos del TAD Abin:
\begin{itemize}
  \item \verb|bool arbolVacio()const;|
  \begin{itemize}
    \item \textit{Post}: Devuelve true si el árbol está vacío, si no false.
  \end{itemize}
  \item \verb|nodo raiz() const;|
  \begin{itemize}
    \item \textit{Post}: Devuelve el nodo que es raíz del árbol, si vacío devuelve \texttt{NODO\_NULO}.
  \end{itemize}
  \item \verb|const T& elemento(nodo n)const;|
  \begin{itemize}
    \item \textit{Pre}: El nodo n existe en el árbol.
    \item \textit{Post}: Devuelve el elemento del nodo n.
  \end{itemize}
  \item \verb|nodo padre(nodo n)const;|
  \begin{itemize}
    \item \textit{Pre}: El nodo n existe en el árbol.
    \item \textit{Post}: Devuelve el padre del nodo n, si no existe devuelve \texttt{NODO\_NULO}.
  \end{itemize}
\end{itemize}