\textbf{\underbar{Enunciado:}}\textit{ A partir de un árbol general, creamos otro intercambiando los subárboles del mismo}

\begin{minted}[breaklines]{C++}
#include <iostream>
#include "agen.h"

template <typename T>
Agen<T> AgenReflejado(const Agen<T> &A){
  //Creamos el agen a devolver
  Agen<T> Reflejado;
  Reflejado.insertarRaiz(A.elemento(A.raiz()));
  //Si la raiz de A no tiene hijo izquierdo, es un árbol que solo contiene un nodo.
  if(A.hijoIzqdo(A.raiz()) != Agen<T>::NODO_NULO)
    return AgenReflejado_rec(A.raiz(),Reflejado.raiz(),A,Reflejado);
  return Reflejado; //devolvemos el árbol general Reflejado
}

template <typename T>
void AgenReflejado_rec(typename Agen<T>::nodo a, typename Agen<T>::nodo b, const Agen<T> &A, Agen<T> &B){
  if(a != Agen<T>::NODO_NULO){ //Comprobamos que a no sea un nodo nulo
    //Vamos a ir recorriendo los hijos de a (y sus nietos, ...) e insertando en el árbol B
    typename Agen<T>::nodo hijo = A.hijoIzqdo(a);
    while(hijo != Agen<T>::NODO_NULO){
      //Si insertamos un hijo izquierdo que ya existe, este se convertirá en hermano derecho automaticamente del nuevo hijo izquierdo que se inserta
      B.insertarHijoIzqdo(b,A.elemento(hijo));
      //Ahora acedemos al hijo de hijo
      AgenReflejado(hijo,b,A,B);
      hijo = A.hermDrcho(hijo); //ahora accedemos a los hermanos.
    }
  }
  //Devolvemos el árbol general Reflejado por referencia
}
\end{minted}
\newpage
Al igual que en el ejercicio con el  árbol binario hemos hecho uso de la representación enlazada pero ahora del árbol general, ya que no tenemos un número de nodos predefinidos, siendo está la parte privada del TAD:
\begin{verbatim}
  private:
    struct celda{
      T elto;
      nodo padre, hizq, hder;
      celda(const T& e, nodo p = NODO_NULO): padre(p),
        hizq(NODO_NULO),hder(NODO_NULO){}
    };
  nodo r; //raíz del árbol
}; //fin del TAD Agen
\end{verbatim}

También hemos hecho uso de los siguientes métodos públicos del TAD Agen:
\begin{itemize}
  \item \verb |Agen<T> Agen();|
  \begin{itemize}
    \item \textit{Post}: Crea y devuelve un Agen vacío.
  \end{itemize}
  \item \verb |void insertarRaiz(const T& e);|
  \begin{itemize}
    \item \textit{Post}: Inserta el elemento en la raíz del árbol.
  \end{itemize}
  \item \verb |const T& elemento (nodo n)const;|
  \begin{itemize}
    \item \textit{Pre}: El nodo n existe en el árbol.
    \item \textit{Post}: Devuelve el elemento del nodo n.
  \end{itemize}
  \item \verb |nodo raiz()const;|
  \begin{itemize}
    \item \textit{Post}: Devuelve el nodo raiz del árbol, si vacío devuelve \texttt{NODO\_NULO}.
  \end{itemize}
  \item \verb |nodo hijoIzqdo(nodo n)const;|
  \begin{itemize}
    \item \textit{Pre}: El nodo n existe en el árbol.
    \item \textit{Post}: Devuelve el hijo izquierdo del árbol, si no existe devuelve \texttt{NODO\_NULO}.
  \end{itemize}
  \item \verb |void insertarHijoIzqdo(nodo n, const T& e);|
  \begin{itemize}
    \item \textit{Pre}: El nodo n existe en el árbol.
    \item \textit{Post}: Inserta el elemento en el hijo izquierdo de n, si existe, el anterior se convierte en su hermano derecho.
  \end{itemize}
  \item \verb |nodo hermDrcho(nodo n)const;|
  \begin{itemize}
    \item \textit{Pre}: El nodo n existe en el árbol.
    \item \textit{Post}: Devuelve el hermano derecho del nodo n, si no existe\\ devuelve \texttt{NODO\_NULO}.
  \end{itemize}
\end{itemize}