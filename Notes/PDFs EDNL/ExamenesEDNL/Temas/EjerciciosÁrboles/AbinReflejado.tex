\textbf{\underbar{Enunciado:}}\textit{ A partir de un árbol binario, creamos otro intercambiando los subárboles del mismo.}

\begin{minted}[breaklines]{C++}
#include <iostream>
#include "abin.h"

template <typename T>
Abin<T> AbinReflejado(const Abin<T> &A){
  //Creamos el nuevo árbol binario 
  Abin<T> Reflejado;
  if(!A.arbolVacio()){
    Reflejado.insertarRaiz(A.elemento(A.raiz()));
    return AbinReflejado_rec(A.raiz(),Reflejado.raiz(),A,Reflejado);
  }
  return Reflejado; //devolvemos el árbol
}

template <typename T>
void AbinReflejado_rec(typename Abin<T>::nodo a, typename Abin<T>::nodo b, const Abin<T> &A, Abin<T> &B){
  if(a != Abin<T>::NODO_NULO){
    //Vamos a insertar en el subárbol izquierdo del nodo b de B el subárbol derecho del nodo a de A y viceversa.
    if(A.hijoDrcho(a)!=Abin<T>::NODO_NULO)
      B.insertarHijoIzqdo(b,A.elemento(A.hijoDrcho(a)));
    //Llamamos a la función recursiva con el subárbol derecho de A y izquierdo de B.
    AbinReflejado(A.hijoDrcho(a),A.hijoIzqdo(b),A,B);
    if(A.hijoIzqdo(a) != Abin<T>::NODO_NULO)
      B.insertarHijoDrcho(b,A.elemento(A.hijoIzqdo(a)));
    //Llamamos a la función con el subárbol izquierdo A y derecho de B.
    AbinReflejado(A.hijoIzqdo(a),B.hijoDrcho(b),A,B);
  }
  //Devolvemos por referencia el árbol B (Reflejado),
}
\end{minted}

\newpage
Para llevar a cabo este ejercicio hemos hecho uso de un árbol binario (ya que no lo especificaba el enunciado) con la representación enlazada, siendo la parte privada del TAD Abin:
\begin{center}
  \begin{verbatim}
  private:
    struct celda{
      T elto;
      nodo padre, hizq, hder;
      celda(const T& e, nodo p = NODO_NULO):elto(e),padre(p),
        hizq(NODO_NULO),hder(NODO_NULO){}
    };
  nodo r; //raíz del árbol
};//fin del TAD
  \end{verbatim}
\end{center}

Además hemos hecho uso de los métodos públicos del TAD Abin:
\begin{itemize}

  \item \verb|Abin<T> Abin();|
  \begin{itemize}
    \item \textit{Post}: Crea y devuelve un Abin vacío.
  \end{itemize}
  \item \verb|bool arbolVacio()const;|
  \begin{itemize}
    \item \textit{Post}: Devuelve true si el árbol está vacío, si no false.
  \end{itemize}
  \item \verb|void insertarRaiz(const T& e);|
  \begin{itemize}
    \item \textit{Pre}: Árbol vacío
    \item \textit{Post}: Inserta el elemento en la raíz del árbol.
  \end{itemize}
  \item \verb|nodo raiz() const;|
  \begin{itemize}
    \item \textit{Post}: Devuelve el nodo que es raíz del árbol, si vacío devuelve \texttt{NODO\_NULO}.
  \end{itemize}
  \item \verb|const T& elemento(nodo n)const;|
  \begin{itemize}
    \item \textit{Pre}: El nodo n existe en el árbol.
    \item \textit{Post}: Devuelve el elemento del nodo n.
  \end{itemize}
  \item \verb|nodo hijoIzqdo(nodo n)const;|
  \begin{itemize}
    \item \textit{Pre}: El nodo n existe en el árbol.
    \item \textit{Post}: Devuelve el hijo derecho del nodo n, si no existe devuelve \texttt{NODO\_NULO}.
  \end{itemize}
  \item \verb|nodo hijoDrcho(nodo n)const;|
  \begin{itemize}
    \item \textit{Pre}: El nodo n existe en el árbol.
    \item \textit{Post}: Devuelve el hijo derecho del nodo n, si no existe devuelve \texttt{NODO\_NULO}.
  \end{itemize}
  \item \verb|void insertarHijoIzqdo(nodo n, const T& e);|
  \begin{itemize}
    \item \textit{Pre}: El nodo n existe en el árbol y no tiene hijo izquierdo previo.
    \item \textit{Post}: Inserta el elemento en el hijo izquierdo de n.
  \end{itemize}
  \item \verb|void insertarHijoDrcho(nodo n, const T& e);|
  \begin{itemize}
    \item \textit{Pre}: El nodo n existe en el árbol y no tiene hijo derecho previo.
    \item \textit{Post}: Inserta el elemento en el hijo derecho de n.
  \end{itemize}
\end{itemize}