Vamos a crear una clase nueva llamada Pedido la cual va a contener información sobre los pedidos que van a poder realizar los Usuarios.

Como vemos en el diagrama contiene 5 atributos:
\begin{itemize}
  \item Dos tipos enteros uno para el número total de pedidos (N\_pedidos) y otro para el número del pedido que se va a realizar.
  \item Un tipo puntero a Tarjeta, que es la tarjeta con la que se realiza el pago.
  \item Un tipo Fecha que es la fecha del pedido.
  \item Un tipo double que es el precio total del pedido.
\end{itemize}

El constructor va recibir los siguientes parámetros:
\begin{itemize}
  \item La asociación entre Usuario y Pedido (Usuario\_Pedido).
  \item La asociación entre Articulo y Pedido (Articulo\_Pedido).
  \item El Usuario que realiza el Pedido.
  \item La Tarjeta con la que se realiza el pago.
  \item La Fecha del pedido, por defecto es la del sistema.
\end{itemize}

Cuando se va a crear el pedido vamos a llamar a los métodos correspondientes para que se relacionen la clases entre sí, estas estarán en las clases de asociación previamente comentadas.

Vamos a crear la clase de excepción \textbf{Pedido::Vacio} para evitar así crear pedidos vacíos. Esta clase tiene un atributo que es un puntero al usuario que realiza el pedido, un constructor que recibe el usuario y un método observador usuario que lo devuelve.

También vamos a declarar la clase de excepción \textbf{Pedido::Impostor}, para poder comprobar que el Usuario que realiza el pedido es el mismo que el titular de la Tarjeta. Al igual que en la clase de excepción anterior, el atributo almacena un puntero al usuario, el constructor recibe el usuario y el observador lo devuelve.

Como los articulos tienen un stock definido, puede ser que algún articulo del carrito supere la cantidad de existencias por eso vamos a crear la clase de excepción \textbf{Pedido::SinStock} que lanzará la excepción y se eliminará el contenido del carrito. Esta clase de excepción consta de un atributo de tipo puntero a Articulo, un constructor que recibe el primer artículo del carrito sin existencias suficientes y un método observador articulo que lo devuelve.

No podemos realizar un pago de un pedido con una tarjeta que esté caducada por tanto, en el construtor de Pedido vamos a lanzar la excepción \textbf{Tarjeta::Caducada} cuando la fecha de caducidad de la tarjeta sea menor a la fecha del pedido. Si la Tarjeta está desactivada vamos a lanzar la excepción \textbf{Tarjeta::Desactivada}. Esta última es una clase de excepción vacía que habrá que añadir a la clase Tarjeta definida en la práctica anterior.

También contamos con varios métodos observadores: \texttt{numero()}, \texttt{tarjeta()}, \texttt{fecha()}, \texttt{total()} y \texttt{n\_total\_pedidos()} que devuelven los atributos correspondientes.

Por último, realizaremos una sobrecargar del operador de inserción en flujo (\texttt{operator <<}) para imprimir un Pedido por pantalla.\\
Mediante el formato:

\texttt{\\
Núm. pedido: 1\\
Fecha: jueves 10 de marzo de 2016\\
Pagado con: VISA n.º: 4539451203987356\\
Importe: 149,95 €\\
}
\subsection{Pedido.hpp}
\begin{minted}[breaklines]{C++}
#ifndef _PEDIDO_HPP_
#define _PEDIDO_HPP_

//Inclusión de librerias y cabeceras
#include "tarjeta.hpp"
#include "usuario.hpp"
#include "articulo.hpp"
#include "usuario-pedido.hpp"
#include "pedido-articulo.hpp"

//Declaraciones adelantadas
class Tarjeta;
class Pedido_Articulo;
class Usuario_Pedido;

class Pedido{
  public:
    Pedido(Usuario_Pedido& ,Pedido_Articulo& ,Usuario& ,const Tarjeta& ,const Fecha& f=Fecha());
    
    //Observadores de la clase
    int numero()const noexcept {return num_;}
    const Tarjeta* tarjeta()const noexcept{return tarjeta_;}
    const Fecha& fecha()const noexcept{return f_pedido_;}
    double total()const noexcept{return importe_Total_;}
    static int n_total_pedidos() noexcept{return n_pedidos_;}

    //clase de la excepcion vacio
    class Vacio{
        Usuario* user_;
      public:
        Vacio(Usuario* user):user_(user){}
        Usuario& usuario()const{return *user_;}
    };

    //clase de la excepción Impostor
    class Impostor{
        Usuario* user_;
      public:
        Impostor(Usuario* user):user_(user){}
        Usuario& usuario()const{return *user_;}
    };

    //clase de la excepción SinStock
    class SinStock{
        Articulo* articulo_;
      public:
        SinStock(Articulo* articulo):articulo_(articulo){}
        Articulo& articulo()const{return *articulo_;}
    };

  private:
    int num_;
    const Tarjeta* tarjeta_;
    Fecha f_pedido_;
    double importe_Total_;
    static int n_pedidos_;
};

//Sobrecarga del operador de flujo
std::ostream& operator <<(std::ostream& ,const Pedido& )noexcept;

#endif //!PEDIDO.HPP
\end{minted}
\subsection{Pedido.cpp}
\begin{minted}[breaklines]{C++}
#include "pedido.hpp"

//Inicializamod la variable static
int Pedido::n_pedidos_ = 0;

//Constructor
Pedido::Pedido(Usuario_Pedido& up,Pedido_Articulo& pa,Usuario& u, const Tarjeta& t,const Fecha& f):num_(n_pedidos_+1),tarjeta_(&t),f_pedido_(f),importe_Total_(0.0){
  //Vamos a comprobar todas la excepciones del constructor de pedido
  //Si el usuario no tiene una compra realizada, el pedido está vacio
  if(u.compra().empty()) throw Pedido::Vacio(&u);

  //Si el usuario es otro al que realiza la compra, excepción
  if(t.titular()!=&u) throw Pedido::Impostor(&u);

  //Si la tarjeta está caducada o desactivada, excepción
  if(t.caducidad() < f_pedido_) throw Tarjeta::Caducada(t.caducidad());

  if(!t.activa()) throw Tarjeta::Desactivada();
  //Si no hay stock del articulo, excepción
  for(auto i : u.compra()){
    if(i.first->stock()<i.second){
      u.vaciar_carro();
      throw Pedido::SinStock(i.first);
    }
  }
  //Creamos la asociación entre las clases una vez que todo está correcto
  /*Asociación Usuario-Pedido*/
  up.asocia(*this,u);
  //actualizamos el importe del pedido y pedimos el articulo
  for(auto& i : u.compra()){
    //importe_Total_ += precio_articulo * cantidad del mismo.
    importe_Total_ += i.first->precio() * i.second;
    pa.pedir((*i.first),*this,i.first->precio(),i.second);

    //restamos el stock del articulo que se ha pedido
    i.first->stock() -= i.second; //sobrecarga del operador -=
  }
  //Aumentamos el numero de pedidos y vaciamos el carro del usuario
  u.vaciar_carro();
  n_pedidos_++;
}

//Insersión en flujo
std::ostream& operator <<(std::ostream& output , const Pedido& ped)noexcept{
  output<<"Núm. pedido: "<<ped.numero()<<std::endl
    <<"Fecha:\t"<<ped.fecha()<<std::endl
    <<"Pagado con: "<<ped.tarjeta()->tipo()<<" n.º: "<<ped.tarjeta()->numero()<<std::endl
    <<"Importe: "<<std::fixed<<std::setprecision(2)<<ped.total()<<" €"<<std::endl;
  return output;
}
  
\end{minted}

