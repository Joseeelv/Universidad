En la práctica anterior definimos e implementamos dos métodos para quitar los espacios y obtener la longitud del Numero (ambos métodos privados de la clase).

Ahora vamos a reimplementar el método de quitar los espacios mediante el uso de dos algoritmos de la STL \texttt{remove\_if()} y \texttt{find\_if()}, donde ambos reciben un predicado.

Para el método \texttt{remove\_if()} vamos a declarar un objeto a función llamado \textbf{Numero::EsBlanco} o bien hacer uso de una función Lambda para detectar si el caracter es un espacio o no mediante el método \texttt{isspace()}.

Por otro lado, para el método \texttt{find\_if()} vamos a hacer uso de un objeto a función llamado \textbf{Numero::EsDigito} para detectar dígitos, y combínelo con el adaptador de negación unaria disponible en \texttt{<functional>} para detectar
caracteres que no sean dígitos. Esta clase la tenemos que definir como miembro público de la clase Numero.

Todo esto se realiza en el constructor de la clase Numero por lo que los métodos anteriores (longitud y eliminar\_espacios) desaparecen.
\subsection{Numero.hpp}
\begin{minted}[breaklines]{C++}
  class Numero{
  public:
    // tipos de excepciones
    typedef enum{ LONGITUD,DIGITOS,NO_VALIDO} Razon;
    Numero(const Cadena &);
  
    // operador de conversion a const char*
    inline operator const char *() const{
        return numero_.operator const char *();}
    // sobrecarga del operador < para comparar numeros
    friend bool operator<(const Numero &, const Numero &);
    // clase de la excepcion
    class Incorrecto{
      Razon razon_;
    public:
      Incorrecto(const Razon &r) : razon_(r){};
      const Razon &razon() const { return razon_; }
    };
    // Objeto a función para comprobar si son digitos
    class EsDigito : public std::unary_function<char, bool>{
    public:
      bool operator()(char caracter) const { return isdigit(caracter); }
    };
  private:
    Cadena numero_;
  };
\end{minted}

\subsection{Numero.cpp}
\begin{minted}[breaklines]{C++}
Numero::Numero(const Cadena& numero){
  Cadena aux(numero);
  //hacemos uso de los predicados para los algoritmos remove_if, find_if
  //Eliminamos los espacios del numero
  auto quitaespacios = std::remove_if(aux.begin(),aux.end(),[](char c){
    return isspace(c);});
  //Modificamos el número fisicamente
  if(quitaespacios != aux.end()){
      aux = aux.substr(0, quitaespacios-aux.begin());
  }
  //negamos que sea un digito y buscamos caracteres que no sean digitos
  auto j = std::find_if(aux.begin(),aux.end(),not_fn(EsDigito()));

  if(j!=aux.end()) //si encuentra un caracter no numérico, excepción
      throw Incorrecto(Razon::DIGITOS); 

  if(aux.length()>19 || aux.length() < 13 || aux.length() == 0)
      throw Incorrecto(Razon::LONGITUD);

  //comprobamos que sea correcto
  if(!luhn(aux))
      throw Incorrecto(Razon::NO_VALIDO);

  //actualizamos el numero sin espacios ni caracteres no numéricos
  numero_ = aux;
}
\end{minted}
