\underbar{\textbf{\large Ejercicio 1:}} Sea cierta clase base B y una derivada D. Ambas tienen definido cierto método \texttt{f()}, pero en B se define como virtual puro.
\begin{enumerate}[label = \alph*)]
  \item Escriba la definición de \textbf{B::f()} (no recibe parámetros ni
  devuelve nada).

  Como dice que no devuelve nada sabemos que es de tipo void, y como es virtual pura tiene que terminar con ``=0', entonces la definición queda como:

  \begin{verbatim} 
  virtual void f() = 0;
  \end{verbatim}

  \item  ¿Qué nombre reciben las clases que son como la clase B?
  
  Las clases que tiene al menos un método virtual puro se denominan clases abstractas, si es el único método que tienen y además es virtual puro se denominan interfaces.
  \item ¿Qué hace el fragmento de código siguiente? ¿Es correcto?
 \begin{figure}[h]
  \begin{minipage}{0.25\textwidth}
    \begin{center}
      \begin{lstlisting}[frame = single]
    B b, *bp;
    D d;
    bp = &d;
    bp->f();
      \end{lstlisting}
    \end{center}
  \end{minipage}
  \hfill
  \begin{minipage}{0.7\textwidth}
    Primero de todo, vemos que la clase B al ser una clase abstracta no puede instanciarse (crear objetos), por tanto, encontramos un error en \texttt{B b}. Luego se realiza una conversión hacia arriba implícitamente y se llama al método \texttt{f()} de D, ya que B es abstracta y por ende polimórfica.
    
  \end{minipage}

 \end{figure}
\end{enumerate}
\underbar{\textbf{\large Ejercicio 2:}} Consideremos la siguiente jerarquía de clases:

\begin{enumerate}[label = \alph*)]
\begin{figure}[h]
  \begin{minipage}{0.38\textwidth}
    \begin{lstlisting}[frame = single]
struct V {
  virtual void fv() = 0;
  virtual ~V() {}
};
struct X : V {
  void fv() { /* ... */ }
};
struct Y : V {
  void fv() { /* ... */ }
};
      \end{lstlisting}    
  \end{minipage}
\hfill
  \begin{minipage}{0.55\textwidth}
    \vspace*{-2.5cm}
      \item ¿Existe una relación de realización entre las clases presentadas? ¿Por qué?\\
      
      Vemos que la clase V es una clase abstracta por lo que si vemos que hay una relación de realización cuando las clases X e Y heredan de ella (V).

  \end{minipage}
\end{figure}

  Supongamos una función \texttt{f()} para procesar objetos de esa jerarquía:
  \begin{center}
    \begin{lstlisting}[frame = single]
void f(V& v) {
  if (typeid(v) == typeid(X)) {
    //codigo especifico para X
    std::cout << "Procesando objeto X...\n"; 
  }
  if (typeid(v) == typeid(Y)) {
    //codigo especifico para Y
    std::cout << "Procesando objeto Y...\n"; 
  }
}
  \end{lstlisting}
\end{center}
  \newpage
  \item ¿Cuál es la salida del siguiente código?

    \begin{minipage}{0.25\textwidth}
      \begin{lstlisting}[frame = single]
  X x; 
  V* pv = new Y;
  f(x); 
  f(*pv);
      \end{lstlisting}
    \end{minipage}
  \hfill
    \begin{minipage}{0.6\textwidth}
    Se realiza una conversión hacia arriba de forma implícita, se llama al método f(x) y devuelve ``Procesando objeto X...'' y luego se llama al método f(*pv), es decir, con el contenido al que apunta el puntero pv y devuelve ``Procesando objeto Y...'
    \end{minipage}

    \item ¿Es la mejor forma de implementar el comportamiento
  polimórfico de \texttt{f()}? En caso negativo, modifique el código
  anterior para mejorarlo y para que produzca la misma salida.

  No, no es la mejor manera ya que mediante polimorfismo podemos redefinir métodos que son virtuales, pero lo que estamos haciendo es comprobar el tipo de dato que se recibe por parámetro y mediante una selectiva devolver una cosa u otra.\\
  Modificación para hacer uso de polimorfismo:

  \begin{minted}[breaklines]{C++}
  struct V {
    virtual void fv() = 0;
    virtual ~V() {}
  };
  struct X : V {
    virtual void fv() override {std::cout << "Procesando objeto X...\n";}
  };
  struct Y : V {
    virtual void fv() override {std::cout << "Procesando objeto Y...\n"; }
  };
  \end{minted}
  Así cada vez que accedamos desde un puntero V al método \texttt{fv()} se llamará a aquel método que corresponda con el tipo del objeto al que apunta, ya que V es asbtacta y por ende polimorfica como comentamos antes.
\end{enumerate}
  
\underbar{\textbf{\large Ejercicio 3:}}
\begin{enumerate}[label = \alph*)]
\item Defina una clase paramétrica llamada \textbf{Buffer} para representar una zona de memoria, cuyos parámetros sean:
\begin{itemize}
  \item El tipo base de cada elemento de esa zona (por omisión, el tipo cuyo tamaño es 1 byte).

  \item El tamaño de dicha zona (por omisión, 256 elementos).
\end{itemize}

\item Defina dentro de la clase el atributo principal, de nombre buf, que será un vector paramétrico (de la STL).


\item Añada el constructor predeterminado. Este ha de invocar el constructor de la clase vector para que inicialice el atributo, creando tantas instancias por defecto del tipo base como indique el tamaño de la zona de memoria. Para esto, utilizaremos el constructor que toma un size\_type.

\begin{minted}[breaklines]{C++}
  template <typename T = byte, size_t n = 256> //Apartado 1
  class Buffer{
      std::vector<T>buf; //Apartado 2
    public:
      Buffer():buf(n){} //Apartado 3
  };
\end{minted}
\end{enumerate}
\newpage

\underbar{\textbf{\large Ejercicio 4:}} Suponga que a la clase Buffer le añadimos los siguientes métodos:

\begin{center}
    \begin{lstlisting}[frame = single]
  void Buffer<T,n>::almacenarDato(char dato, size_t indice){
    if(indice < buf.size()) 
      buf[indice] = dato;
    else
      throw std::out_of_range("Almacenar: fuera de rango");
  }
  char Buffer<T,n>::recuperarDato(size_t indice) const {
    if(indice < buf.size())
      return buf.at(indice);
    else 
      throw std::out_of_range("Recuperar: fuera de rango");
  }
  \end{lstlisting}
\end{center}
\begin{enumerate}[label = \alph*)]
\item  ¿Qué problemas observas? ¿Falta algo en este código? Haga los cambios oportunos en el código proporcionado.

Vemos que en el método \texttt{almacenarDato} está intentando guardar un char cuando el tipo de dato es T, es decir tendría que poner T dato ya que estamos haciendo uso de una plantilla.

Lo mismo sucede en el método \texttt{recuperarDato} donde devuelve un char y debería de devolver un T, ya que el método tiene que valer para cualquier tipo de dato.

\begin{minted}[breaklines]{C++}
  template<T,size_t n>
  void Buffer<T,n>::almacenarDato(T dato, size_t indice){
    if(indice < buf.size()) 
      buf[indice] = dato;
    else
      throw std::out_of_range("Almacenar: fuera de rango");
  }
  template<T,size_t n>
  T Buffer<T,n>::recuperarDato(size_t indice) const {
    if(indice < buf.size())
      return buf.at(indice);
    else 
      throw std::out_of_range("Recuperar: fuera de rango");
  }
\end{minted}

\item Cree una clase Almacenamiento, la cual siempre estará formada por
una memoria de 128 elementos de tipo double. Por lo tanto, el siguiente programa imprimiría ``Almacenar: fuera de rango".

\begin{center}
  \begin{lstlisting}[frame = single]
  int main() {
    Almacenamiento almacen;
    try{
      almacen.almacenarDato(4.0, 129);
      std::cout << almacen.recuperarDato(1);
    }catch(std::out_of_range& oor){
      std::cerr << oor.what() << std::endl;
    }
  }
  \end{lstlisting}
\end{center}

\begin{minted}[breaklines]{C++}
  class Almacenamiento : public Buffer<double,128>{
  };
\end{minted}

\item Defina e implemente la clase Almacenamiento para que, haciendo uso de la clase Buffer, se ajsute a lo anterior.
\begin{minted}[breaklines]{C++}
  class Almacenamiento : public Buffer<double,128>{
    public:
      Almacenamiento():Buffer<double,128>(){}
  };
\end{minted}
\end{enumerate}