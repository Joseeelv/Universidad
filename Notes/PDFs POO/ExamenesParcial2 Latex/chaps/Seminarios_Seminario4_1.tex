\underbar{\textbf{\large Ejercicio 1:}} Dado el siguiente código:

\begin{center}
  \begin{lstlisting}[frame = single]
using namespace std;
struct A {
  void mostrar(int i){cout<< i << "[A-entero]"<<endl;}
  void mostrar(float f){cout<< f <<"[A-real]"<<endl;}
};
struct B: A {
  void mostrar(float f){cout<<f<<"[B-real]"<<endl;}
};
  \end{lstlisting} 
\end{center}

\underbar{¿Qué mostrarán cada una de las siguientes llamadas a mostrar?}
\begin{figure}[h]
  \begin{minipage}{0.15\textwidth}
    \vspace*{-1cm}
\texttt{A a;}\\\texttt{a.mostrar(4);}\\ \texttt{a.mostrar(4.1);}\\

\texttt{B b;}\\\texttt{b.mostrar(4);}\\ \texttt{b.mostrar(4.1);}
  \end{minipage}
\hfill
  \begin{minipage}{0.75\textwidth}
    La clase A tiene dos métodos mostrar (uno para int y otro para float), por tanto:\\
    \texttt{a.mostrar(4);}→ 4[A-entero]\\
    \texttt{a.mostrar(4.1);}→ 4.1[A-real]\\

    La clase B tiene un método mostrar (float), por tanto:\\
    \texttt{b.mostrar(4);}→ 4[B-real] \\
    \texttt{b.mostrar(4.1);}→4.1[B-real] \\
  \end{minipage}  
\end{figure}

Vemos que en el caso de llamar \texttt{b.mostrar(4);}, este va a devolver 4[B-real], debido a que no tiene definido un mostrar en dicha clase y hace uso del mostrar con float donde realiza una conversión implícita a dicho tipo de dato. Si definimos un mostrar con entero en B, devolvería ese y no el de float.

\underbar{\textbf{\large Ejercicio 2:}} Sea cierta clase base B y una derivada D. Ambas tienen definido un cierto método f(). Diga si el siguiente código es correcto; y, si lo es, a qué método f() se llamaría, dependiendo de que B::f() sea o no virtual.

\begin{figure}[h]
  \begin{minipage}{0.2\textwidth}
    \begin{lstlisting}[frame = single]
  B b, *bp;
  D d, *dp;
  bp=&d;
  bp->f();
  dp=&b;
  dp->f();
  dp=&d;
  dp->f();
    \end{lstlisting}
  \end{minipage}
  \hfill
  \begin{minipage}{0.75\textwidth}
    \underbar{B::f() no virutal, B no es polimorfica:}\\
    \textbf{\texttt{bp->f();}}→ Conversión hacia arriba previa, se llama a B::f().  \\
    \textbf{\texttt{dp->f();}}→Error previo a la hora de realizar una conversión hacia abajo. Si se hace bien la conversión se llama a D::f().\\
    \textbf{\texttt{dp->f();}}→ Se llama a D::f().\\

    \underbar{B::f() virutal, B es polimorfica:}\\
    \textbf{\texttt{bp->f();}}→ Se llama a D::f().\\
    \textbf{\texttt{dp->f();}}→ Si se hace la conversión correctamente, se llama a B::f(). \\
    \textbf{\texttt{dp->f();}}→ Se llama a D::f().\\
  \end{minipage}
\end{figure}

\newpage
\underbar{\textbf{\large Ejercicio 3:}} Indique qué enviará exactamente a la salida estándar el siguiente programa al ejecutarse:
\begin{center}
  \begin{lstlisting}[frame = single]
#include <iostream>
struct B {
  B() { std::cout << "Constructor de B\n"; }
  virtual ~B() { std::cout << "Destructor de B\n"; }
};
struct D: B {
   D() { std::cout << "Constructor de D\n"; }
  ~D() { std::cout << "Destructor de D\n"; }
};
int main() {
  B *pb = new D;
  delete pb;
}
  \end{lstlisting}
\end{center}

¿Que destructores son virtuales? ¿Cambiaría algo si quitamos la palabra virtual del destructor B?

El único destructor que es virtual es el de la clase B.
Si quitamos la palabra virtual no se llamará al destructor de la clase Derivada, haciendo que no se elimine correctamente el objeto de la misma clase.

\underbar{\textbf{\large Ejercicio 4:}} ¿Cambiaría el comportamiento de la clase cuadrado si le quitamos el miembro \texttt{area()}?

\begin{lstlisting}[frame = single]
class rectangulo {
  public:
    rectangulo(double a, double l): ancho(a), largo(l) {}
    virtual double area() { return ancho * largo; }
    virtual ~rectangulo() = default;
  private:
    double ancho, largo;
};
class cuadrado: public rectangulo {
  public:
    cuadrado (double l): rectangulo(l, l) {}
    double area() { return rectangulo::area(); }
};
\end{lstlisting}

No, no cambiaría nada porque al quitar dicho miembto hará uso del método area () de la clase rectangulo (base), es el mismo comportamiento si no quitamos el método ya que en cuadrado se redefine delegando en el método area() de rectangulo.


 