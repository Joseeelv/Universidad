\chapter{Agregación y Composición}
La diferencia entre agregación (’diamante vacío’, menos restrictiva) y composición (‘diamante relleno’, más restrictiva).
Véase en Libro y Capítulo (Introduccion a las relaciones), donde un Libro no puede existir si no existen Capítulos (composición).

La composición es un tipo de agregación donde existe dos restricciones, de \textbf{multiplicidad} (un componente solo puede formar parte de un compuesto) y \textbf{existencia} (la vida del componente depende del compuesto).\\
Mediante las composiciones también hacemos uso de la reutilización del clases, donde hacemos uso de la clase Capítulo para definir la clase Libro.
\vspace{-0.5cm}
\section{Relación de agregación}
\begin{quote}
	Es la relación de asociación entre una clase y un agregado (conjunto).
\end{quote}
Normalmente, son \underbar{unidireccionales}, la clase componente no conoce nada de la clase compuesta por ella misma.

Se implementan como relaciones de \textbf{asociación} pero son unidireccionales donde solamente almacena el contenido
la clase que es compuesta (la tiene el diamante).

\vspace{-0.5cm}
\section{Relación de Composición}
\begin{quote}
	Es la relación de asociación entre un componente y un compuesto, pero es más restrictiva que la relación de agregación.
\end{quote}
El atributo que añadimos a la clase compuesta, ya no es un puntero, si no el objeto como tal.

Si la multiplicidad es 1 → solamente un atributo, si no, tendremos un contenedor del tipo de la clase componente.
Podemos hacer uso de estas relaciones para la reutilización de software.
\subsection{ Implementación de composición 1 - 1..N}
\begin{center}
	\begin{lstlisting}[frame=single]
class B; //declaracion adelantada
class A{ //Compuesto
  public:
    //A se crea a partir de un objeto de B
    A(B& b){ setB(b); }
    typedef std::set<B> BS;
    void setB(const B& b)noexcept{bs_.insert(b);}
      
  private:
    BS bs_;
};
class B{//Componente
//No recibe nada del compuesto
  public:
    friend bool operator < (const B& a, const B& b) noexcept;
};
\end{lstlisting}
\end{center}
En este tipo de relaciones al tener un \texttt{set} de objetos de la clase \textit{componente} necesitamos definir una manera de ordenar los elementos que componen, por eso sobrecargamos el operador menor que '$<$'.

\subsection{Implementación de composición 1 - 1}
\begin{center}
	\begin{lstlisting}[frame=single]
class A{ //Compuesto
 public:
   A(B& b):b_(b){} //A se crea a partir de un objeto de B
 private:
   B b_;
};
class B{//Componente
   //No recibe nada del compuesto
};
\end{lstlisting}
\end{center}

\subsection{Implementación de composición 1 - 1 (herencia privada)}
\begin{center}
	\begin{lstlisting}[frame=single]
class A : private B{ //Compuesto
 public:
   A(B& b): B(b){} //A se crea a partir de un objeto de B
};
class B{//Componente
   //No recibe nada del compuesto
};
\end{lstlisting}
\end{center}