\chapter{Agregación y Composición}
La diferencia entre agregación (’diamante vacío’, menos restrictiva) y composición (‘diamante relleno’, más restrictiva).
Véase en Libro y Capítulo (Introduccion a las relaciones), donde un Libro no puede existir si no existen Capítulos (composición).

La composición es un tipo de agregación donde existe dos restricciones, de \textbf{multiplicidad} (un componente solo puede formar parte de un compuesto) y \textbf{existencia} (la vida del componente depende del compuesto).\\
Mediante las composiciones también hacemos uso de la reutilización del clases, donde hacemos uso de la clase Capítulo para definir la clase Libro.
\vspace{-0.5cm}
\section{Relación de agregación}
\begin{quote}
	Es la relación de asociación entre una clase y un agregado (conjunto).
\end{quote}
Normalmente, son \underbar{unidireccionales}, la clase componente no conoce nada de la clase compuesta por ella misma.

Se implementan como relaciones de \textbf{asociación} pero son unidireccionales donde solamente almacena el contenido
la clase que es compuesta (la tiene el diamante).

\vspace{-0.5cm}
\section{Relación de Composición}
\begin{quote}
	Es la relación de asociación entre un componente y un compuesto, pero es más restrictiva que la relación de agregación.
\end{quote}
El atributo que añadimos a la clase compuesta, ya no es un puntero, si no el objeto como tal.

Si la multiplicidad es 1 → solamente un atributo, si no, tendremos un contenedor del tipo de la clase componente.
Podemos hacer uso de estas relaciones para la reutilización de software.
\subsection{ Implementación de composición}
\begin{center}
	\begin{lstlisting}[frame=single]
class A{ //Compuesto
 public:
   A(B& ); //A se crea a partir de un objeto de B
   typedef std::set<B> Bs_;
   friend operator < (const A&, const A&);
 private:
   BS bs_;
};

class B{//Componente
   //No recibe nada del compuesto
};
\end{lstlisting}
\end{center}
En este tipo de relaciones al tener un \texttt{set} de objetos de la clase \textit{componente} necesitamos definir una manera de ordenar los elementos que componen, por eso sobrecargamos el operador menor que '$<$'.