\thispagestyle{empty}
\cleardoublepage
\chapter{Teoría de la STL}

La \textit{STL} (Standard Template Library) de C++ es una parte integral del estándar de C++ que proporciona una colección de plantillas y algoritmos genéricos, así como tipos de datos contenedores y funciones asociadas para facilitar el desarrollo de software.

La \textit{STL} fue diseñada para ser flexible, eficiente y fácil de usar.

En este último caso encontramos \texttt{set} (conjunto de objetos de un tipo determinado) y \texttt{map} (diccionario clave - valor).
Además encontramos sus variantes donde podemos encontrar valores repetidos como son \texttt{multiset} ó \texttt{multimap} y sus variantes donde el contenido de estos contenedores no están ordenados \texttt{unordered\_set} y \texttt{unordered\_map}, respectivamente.

La \textit{STL} proporciona una amplia gama de algoritmos genéricos que operan con los tipos de datos contenedores como: vectores \texttt{vector}, listas doblemente enlazadas \texttt{list},
bicolas \texttt{deque}, pilas \texttt{stack} o contenedores que contienen una colección de objetos de un tipo determinado.

\section{Iteradores}
Mediante los \texttt{iterators} (iteradores) podemos acceder a las posiciones o elementos contenidos en cada tipo de contenedor.
Se recomienda el uso de la \textit{keyword} \texttt{auto}, para que el compilador le asigne el tipo adecuado al iterador.

\underbar{\textbf{\large{Librería}}} → \texttt{<iterator>}

Todos los tipos contendores asociativos pueden hacer uso de estos iteradores, donde encontramos varios métodos de acceso a las posiciones 
de los contenedores:
\begin{itemize}
  \item \texttt{begin()} (puntero a la primera posición) y \texttt{cbegin()}(puntero constante a la primera posición).
  \item \texttt{end()} (puntero a la siguiente posición del final del contendor) y \texttt{cend()} (puntero constante a la siguiente posición del final del contendor).
\end{itemize}

\section{Contenedores asociativos de la STL}
Vamos a ver con un poco más de profundidad los contenedores asociativos que son los que usaremos al implementar las relaciones entre clases de objetos en C++.
\subsection{Conjunto de objetos: Set}
El contendor asociativo \texttt{set} es un conjunto de elementos no duplicados de un mismo tipo.
Pueden estar ordenados (\texttt{set}) ó desordenados (\texttt{unordered\_set}).

\underbar{\textbf{\large{Librería}}} →  \texttt{<set>}, donde se incluye todos los métodos de los que puede hacer uso mediante iteradores.
\newpage
\textbf{\large{Sintaxis conjunto valores no repetidos:}}
\begin{figure}[h]
  \begin{center}
    \begin{lstlisting}[frame = single]
                  typedef std::set<T>Alias;
    \end{lstlisting}
\end{center}
Se hace uso de Alias cuando se define en la parte pública de la clase, si fuera en la privada, ese sería el nombre
del contenedor.
\end{figure}

\textbf{\large{Sintaxis conjunto valores repetidos:}}
\begin{figure}[h]
  \begin{center}
    \begin{lstlisting}[frame=single]
                  typedef std::multiset<T>Alias;
    \end{lstlisting}
  \end{center}
\end{figure}

El tipo \textbf{\texttt{T}} definido en el set puede ser un \textbf{tipo de dato (objeto)} o un \textbf{puntero}. Si el tipo es un objeto tendremos que realizar
una sobrecarga de un operador de ordenación, ya sea el operador \texttt{<} o el operador \texttt{>} para ordenadar los elementos del conjunto,
esto es lo que sucede a la hora de implementar la \textbf{relación de composición} entre dos clases.

Si es de \textbf{ tipo puntero}, no hace falta realizar esta sobrecarga para ordenar los elementos.

\subsubsection{Operaciones del contenedor asociativo set:}
Vamos a ver las operaciones más comunes que usaremos a la hora de implementar un conjunto de elemento en las relaciones entre clases.
\begin{center}
  \begin{lstlisting}[frame = single]
#include <set>
set<T> conjunto;
/*-----------INSERCION------------*/
conjunto.insert(const T& e); // inserta un elemento en el conjunto.
/*----------ELIMINACION----------*/
conjunto.erase(iterator p); // elimina el elemento que se encuentre en la posicion.
conjunto.clear(); // elimina todos los elementos del conjunto
/*----------ACCESO---------- */
conjunto.begin(); //devuelve iterador al primer elemento del conjunto.
conjunto.end(); //devuelve iterador siguiente del ultimo elemento del conjunto.
conjunto.find(const T& e); //Devuelve el iterador que apunta ese elemento.
/*----------CONSULTA---------- */
conjunto.empty(); //Devuelve V o F si esta vacio o no.
conjunto.size(); //Devuelve el tam del conjunto
  \end{lstlisting}
\end{center}

\subsection{Diccionario clave - valor: Map}
El contenedor asociativo \texttt{map} es un diccionario de pareja clave única y valores o conjunto de valores.
Al igual que el contendor asociativo \textit{set}, \texttt{map} también es un contenedor donde las claves se insertan de manera ordenada,
si no queremos un diccionario ordenado, podemos hacer uso de \texttt{unordered\_map}.\

\underbar{\textbf{\large{Librería}}} → \texttt{<map>}, donde se incluye todos los métodos de los que puede hacer uso mediante iteradores, al igual que \texttt{set}.

\textbf{\large{Sintaxis clave - valor:}}

\begin{figure}[h]
  \begin{center}
    \begin{lstlisting}[frame=single]
                  typedef std::map<T1,T2>Alias;
    \end{lstlisting}
  \end{center}
  Aqui vemos que la declaración se realiza con una clave y un valor que puede tomar cualquier 
  valor (T1 y T2, si estuvieramos en una plantilla).
\end{figure}

\textbf{\large{Sintaxis clave - conjunto valores:}}

\begin{center}
  \begin{lstlisting}[frame=single]
                typedef std::multimap<T1,T2>Alias;
  \end{lstlisting}
\end{center}


Este \texttt{multimap} lo podemos implementar de una manera más intuitiva:
\begin{center}
  \begin{lstlisting}[frame=single]
              typedef std::map<T1,conjunto>Alias;
  \end{lstlisting}
\end{center}

A la hora de declararlo mediante \underbar{conjunto} de elementos dento de un \texttt{map}, dicho conjunto puede ser un \texttt{set}, \texttt{unordered\_set},
   \texttt{map}, \texttt{unordered\_map} o \texttt{pair}.

Se hace uso de Alias cuando se define en la parte pública de la clase, si fuera en la privada, ese sería el nombre
del contenedor.

Mediante los \textbf{iteradores} podemos acceder tanto a la clave (\texttt{first}) como al valor (\texttt{second}).

\subsubsection{Operaciones del contenedor asociativo map:}
Vamos a ver las operaciones más comunes que usaremos a la hora de implementar un diccionario en las relaciones entre clases.
\begin{center}
  \begin{lstlisting}[frame = single]
#include <map>
map<T,U>diccionario;
/*-----------INSERCION------------*/
//inserta para una clave un valor
diccionario.insert(std::make_pair(const T& clave, const U& valor));
diccionario[const T& clave] = &valor; //permite modificar el valor si ya hay un valor previo insertado en esa clave.
/*-----------ELIMINACION------------*/
diccionario.erase(iterator p); //elimina la clave de la posicion p.
diccionario.erase(); //elimina todo el diccionario
/*-----------ACCESO------------*/
diccionario.begin(); //Devuelve iterador a la primera clave del diccionario.
diccionario.fin(); //Devuelve iterador a la siguiente posicion de la ultima clave del diccionario.
diccionario[const T& clave];//accede al valor de la clave dada
/*----------CONSULTA---------- */
diccionario.empty(); //Devuelve V o F si esta vacio o no.
diccionario.size(); //Devuelve el tam del conjunto
  \end{lstlisting}
\end{center}

\subsection{Tupla de dos elementos: Pair}
Esta es una clase genérica la cual permite crear pareja de valores únicos de cualquier tipo T.

\underbar{\textbf{\large{Librería}}} →  \texttt{<utility>}, una cosa a tener en cuenta es que las parejas de elementos
no tienen los métodos \texttt{insert()}, \texttt{erase()}, por lo que a la hora de insertar lo haremos mediante asignación.

\textbf{\large{Sintaxis tupla de valores:}}
\begin{center}
  \begin{lstlisting}[frame=single]
                typedef std::pair<T1,T2>Alias;
  \end{lstlisting}
  \end{center}
Siendo T1 y T2 los tipos de los dos elementos que almacena.

Este tipo de tuplas son muy útiles cuando encontramos multiplicidades 1 - muchos en las relaciones entre clases y la
podemos declarar dentro de los diccionarios \texttt{map}.

\section{Algoritmos de búsqueda y ordenación}
Para poder buscar elementos en un contenedor podemos hacer uso de \texttt{find}, \texttt{binary\_search}.
Podemos ordenar los elementos de los contenedores mediante los algoritmos \texttt{sort}.
\section{Algoritmos de modificación}
Podemos realizar varias modificaciones en los contenedores mediante varios algoritmos como \texttt{std::copy} (donde hacemos una copia de todos los elementos de un contenedor en otro),
\texttt{std::fill} (rellenamos el contenedor con elementos), \texttt{std::move} (donde movemos el contenido de un contenedor a otro, se realiza mediante la semántica de movimiento de C++.)

\section{Funciones Lambda y Objetos a Función}

Encontramos varios \textit{algoritmos de la STL} que para su ejecución necesitan que se satisfaga una condición o predicado.
Estos predicados pueden ser tanto \textbf{funciones lambda} ó \textbf{objetos a función}.

\subsection{Funciones Lambda en C++}
Permiten definir funciones anónimas de manera concisa y local. Las funciones \textit{Lambda}proporcionan una forma de crear funciones en el lugar donde se necesitan,
sin tener que definir una función por separado.

Consiste en tres partes → lista de captura \texttt{[]} , parámetro opcional de captura \texttt{()} y un cuerpo \texttt{\{\}}.

Cuando se evalúa una función \textit{Lambda}, se produce un objeto llamado \textit{closure}. Este objeto ‘\textit{closure}’ no tiene ni nombre ni tipo y es temporal.
\begin{center}
	\begin{lstlisting}[frame=single]
auto nombre_funcion = [captura](parametros){
 //cuerpo de la funcion
 // Puede acceder a las variables capturadas y usar parametros
 return expresion;
}
	\end{lstlisting}
\end{center}

\textbf{Tipo de retorno} → Especifica el tipo de dato que la función \textit{Lambda}devolverá. Puede ser omitido si esta no devuelve un valor explícitamente.

\textbf{Captura} → Permite a la función lambda acceder a las variables fuera de su alcance local. Puede ser por valor \texttt{[x]} , por referencia \texttt{[\&x]} , por valor pero modificable \texttt{[x] mutable} , por referencia (solo lectura) \texttt{[\&x]mutable} o capturar todas las variables automáticamente \texttt{[=]} ó \texttt{[\&]}.

\textbf{Parámetros} → Los parámetros de la función \textit{Lambda} son similares a los usados en las funciones regulares. Si no tiene parámetros ‘\texttt{()}` ’ estos paréntesis serán omitidos a no ser que se necesites declarar la función \textit{Lambda} como \texttt{mutable}.

\textbf{Cuerpo de la función}→ El ‘\textit{body}’ contiene la lógica de la función \textit{Lambda} (como una función regular).

\textbf{Expresión} → Valor de la función \textit{Lambda} puede devolver (opcional si la función no devuelve nada o si el tipo de retorno es \texttt{void}).


\subsubsection{Ejemplo del uso de función Lambda}
\begin{center}
	\begin{lstlisting}[frame=single]
int main(){
//Funcion Lambda que suma dos numeros
  auto suma = [](int a, int b){return a+b;}
//Uso de la funcion Lambda
  int resultado = suma(5,7);
  std::cout<<"Resultado: "<<resultado<<std::endl;
  return 0;
}
	\end{lstlisting}
\end{center}
Vemos que en este ejemplo, la función Lambda \texttt{suma} toma dos parámetros ‘a’ y ‘b’ de tipo enteros ambos y devuelve el resultado de la suma de ambos.
La función se almacena en una variable \texttt{auto} y luego se utiliza como cualquier otra función.
\newpage
\subsubsection{Ejemplo del uso de función Lambda mutable}
La \textit{keyword} \texttt{mutable} permite que la función Lambda pueda ser modificada, ya que estas por defecto son no modificables \texttt{const}. 
\begin{center}
	\begin{lstlisting}[frame=single]
int main(){
  int a =0;
  //Error, operator () es const
  auto bad_counter = [a](){return a++;} 
  //Correcto, operator () es mutable
  auto good_counter = [a]()mutable{return a++;}
  //Llamamos al metodo
  good_counter(); //a=1
  good_counter(); //a=2;
  return 0;
}
	\end{lstlisting}
\end{center}

\subsection{Objeto Función en C++}
Los \textbf{objetos función} o \textbf{funtores}: Son objetos que se comportan como funciones. Es una instancia de una clase que sobrecarga el operador \texttt{operator()}. 

\textbf{Definición mediante clases}: Para crear un objeto función, necesitas definir una clase que tenga el operador de llamada sobrecargado.
\begin{center}
	\begin{lstlisting}[frame=single]
struct Suma{
  int operator() (int a , int b) const {return a+b;}
};

int main(){
  Suma objetoFuncion;
  //creamos una variable con el resultado de llamar al objeto a funcion
  int resultado = objetofuncion(3,4);
  return 0;
}
	\end{lstlisting}
\end{center}

\section{Algoritmos de la STL}
Mediante lo visto anteriormente podemos hacer uso de algoritmos para poder manipular el contenido de los contenedores de la \textit{STL}.
Hay algunos algoritmos que haran uso de los \textbf{iteradores}, otros el uso de \textbf{predicados} o ambos.

\subsection{std::count\_if}
Lo encontramos en la librería \texttt{<algorithm>}.
Devuelve el número de veces que se repite un elemento en el rango [inicio,fin) de un contenedor.
\begin{center}
	\texttt{std::count\_if(iterador\_ini,iterador\_fin,predicado);}
\end{center}

\subsection{std::remove\_if}Lo encontramos en la librería \texttt{<algorithm>}.

Elimina el elemento que cumple la condición dada por el predicado en el rango [inicio,fin) del contendor.
\begin{center}
	\texttt{std::remove\_if(iterador\_ini,iterador\_fin, predicado);}
\end{center}

\subsection{std::lower\_bound}
Lo encontramos en la librería \texttt{<algorithm>}.
Devuelve un iterador apuntando a la primera posición donde el elemento que se le pasa es '\textbf{\textless}' que el siguiente elemento.
Es muy útil para la inserción o búsqueda de elementos de un contenedor ordenado.
\begin{center}
	\texttt{std::lower\_bound(ini\_rango,fin\_rango,const T\& elto);}
\end{center}

\subsection{std::insert}
Este método está contenido en todas las librerías de los contenedores de la \textit{STL} como \textbf{vector}, \textbf{map}, \textbf{set} y los demás tipos contenedores excepto \texttt{std::pair}, como este no tiene el método \texttt{insert}, la inserción se hará por asignación.
Inserta el elemento especificado dado un iterador, es decir, colocará dicho elemento en la posición del contenedor que le especifiquemos.
\begin{center}
	\texttt{std::insert(const\_iterator pos, const T\& elto);}
\end{center}

\subsection{std::erase}
Este método al igual que \texttt{std::insert} se define en cada contenedor de la \textit{STL}.
Elimina un elemento específico que se encuentre contenido en un contenedor dando su posición (iterador).
\begin{center}
	\texttt{std::erase(const\_iterator pos);}
\end{center}

\subsection{std::find}
Se encuentra en la librería \texttt{<algorithm>}.
Devuelve un iterador al primer elemento del rango [inicio,fin) que satisface un criterio específico.

Muy útil para buscar elementos contenidos en un tipo contenedor.
\begin{center}
	\texttt{auto i = nombre\_contenedor.find(T\& elto);}
\end{center}




























